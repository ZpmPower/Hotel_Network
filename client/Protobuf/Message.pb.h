// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Message.proto

#ifndef PROTOBUF_Message_2eproto__INCLUDED
#define PROTOBUF_Message_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "MessageType.pb.h"
// @@protoc_insertion_point(includes)

namespace network {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Message_2eproto();
void protobuf_AssignDesc_Message_2eproto();
void protobuf_ShutdownFile_Message_2eproto();

class AuthMessage;
class RegisterMessage;
class RegisterEmployeeMessage;
class GuestInfo;
class GuestsMessageResponse;
class EmployeeInfo;
class EmployeesMessageResponse;
class HotelId;
class HotelInfo;
class HotelsMessageResponse;
class RoomInfo;
class RoomsMessageResponse;
class VacantRooms;
class OrderInfo;
class OrdersMessageResponse;
class GuestOrderInfo;
class GuestOrdersMessageResponse;
class MakeOrderInfo;
class RequestContext;
class RegisterMessageResponse;
class AuthMessageResponse;
class SessionInfo;
class RoomTypesMessageResponse;
class HotelType;
class HotelTypesMessageResponse;
class ResponseContext;

// ===================================================================

class AuthMessage : public ::google::protobuf::Message {
 public:
  AuthMessage();
  virtual ~AuthMessage();

  AuthMessage(const AuthMessage& from);

  inline AuthMessage& operator=(const AuthMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AuthMessage& default_instance();

  void Swap(AuthMessage* other);

  // implements Message ----------------------------------------------

  AuthMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AuthMessage& from);
  void MergeFrom(const AuthMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string login = 1;
  inline bool has_login() const;
  inline void clear_login();
  static const int kLoginFieldNumber = 1;
  inline const ::std::string& login() const;
  inline void set_login(const ::std::string& value);
  inline void set_login(const char* value);
  inline void set_login(const char* value, size_t size);
  inline ::std::string* mutable_login();
  inline ::std::string* release_login();
  inline void set_allocated_login(::std::string* login);

  // optional string pass = 2;
  inline bool has_pass() const;
  inline void clear_pass();
  static const int kPassFieldNumber = 2;
  inline const ::std::string& pass() const;
  inline void set_pass(const ::std::string& value);
  inline void set_pass(const char* value);
  inline void set_pass(const char* value, size_t size);
  inline ::std::string* mutable_pass();
  inline ::std::string* release_pass();
  inline void set_allocated_pass(::std::string* pass);

  // @@protoc_insertion_point(class_scope:network.AuthMessage)
 private:
  inline void set_has_login();
  inline void clear_has_login();
  inline void set_has_pass();
  inline void clear_has_pass();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* login_;
  ::std::string* pass_;
  friend void  protobuf_AddDesc_Message_2eproto();
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static AuthMessage* default_instance_;
};
// -------------------------------------------------------------------

class RegisterMessage : public ::google::protobuf::Message {
 public:
  RegisterMessage();
  virtual ~RegisterMessage();

  RegisterMessage(const RegisterMessage& from);

  inline RegisterMessage& operator=(const RegisterMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterMessage& default_instance();

  void Swap(RegisterMessage* other);

  // implements Message ----------------------------------------------

  RegisterMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegisterMessage& from);
  void MergeFrom(const RegisterMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string login = 1;
  inline bool has_login() const;
  inline void clear_login();
  static const int kLoginFieldNumber = 1;
  inline const ::std::string& login() const;
  inline void set_login(const ::std::string& value);
  inline void set_login(const char* value);
  inline void set_login(const char* value, size_t size);
  inline ::std::string* mutable_login();
  inline ::std::string* release_login();
  inline void set_allocated_login(::std::string* login);

  // optional string pass = 2;
  inline bool has_pass() const;
  inline void clear_pass();
  static const int kPassFieldNumber = 2;
  inline const ::std::string& pass() const;
  inline void set_pass(const ::std::string& value);
  inline void set_pass(const char* value);
  inline void set_pass(const char* value, size_t size);
  inline ::std::string* mutable_pass();
  inline ::std::string* release_pass();
  inline void set_allocated_pass(::std::string* pass);

  // optional string firstname = 3;
  inline bool has_firstname() const;
  inline void clear_firstname();
  static const int kFirstnameFieldNumber = 3;
  inline const ::std::string& firstname() const;
  inline void set_firstname(const ::std::string& value);
  inline void set_firstname(const char* value);
  inline void set_firstname(const char* value, size_t size);
  inline ::std::string* mutable_firstname();
  inline ::std::string* release_firstname();
  inline void set_allocated_firstname(::std::string* firstname);

  // optional string secondname = 4;
  inline bool has_secondname() const;
  inline void clear_secondname();
  static const int kSecondnameFieldNumber = 4;
  inline const ::std::string& secondname() const;
  inline void set_secondname(const ::std::string& value);
  inline void set_secondname(const char* value);
  inline void set_secondname(const char* value, size_t size);
  inline ::std::string* mutable_secondname();
  inline ::std::string* release_secondname();
  inline void set_allocated_secondname(::std::string* secondname);

  // optional string lastname = 5;
  inline bool has_lastname() const;
  inline void clear_lastname();
  static const int kLastnameFieldNumber = 5;
  inline const ::std::string& lastname() const;
  inline void set_lastname(const ::std::string& value);
  inline void set_lastname(const char* value);
  inline void set_lastname(const char* value, size_t size);
  inline ::std::string* mutable_lastname();
  inline ::std::string* release_lastname();
  inline void set_allocated_lastname(::std::string* lastname);

  // optional string phonenumber = 6;
  inline bool has_phonenumber() const;
  inline void clear_phonenumber();
  static const int kPhonenumberFieldNumber = 6;
  inline const ::std::string& phonenumber() const;
  inline void set_phonenumber(const ::std::string& value);
  inline void set_phonenumber(const char* value);
  inline void set_phonenumber(const char* value, size_t size);
  inline ::std::string* mutable_phonenumber();
  inline ::std::string* release_phonenumber();
  inline void set_allocated_phonenumber(::std::string* phonenumber);

  // optional string passport = 7;
  inline bool has_passport() const;
  inline void clear_passport();
  static const int kPassportFieldNumber = 7;
  inline const ::std::string& passport() const;
  inline void set_passport(const ::std::string& value);
  inline void set_passport(const char* value);
  inline void set_passport(const char* value, size_t size);
  inline ::std::string* mutable_passport();
  inline ::std::string* release_passport();
  inline void set_allocated_passport(::std::string* passport);

  // optional int32 role = 8;
  inline bool has_role() const;
  inline void clear_role();
  static const int kRoleFieldNumber = 8;
  inline ::google::protobuf::int32 role() const;
  inline void set_role(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:network.RegisterMessage)
 private:
  inline void set_has_login();
  inline void clear_has_login();
  inline void set_has_pass();
  inline void clear_has_pass();
  inline void set_has_firstname();
  inline void clear_has_firstname();
  inline void set_has_secondname();
  inline void clear_has_secondname();
  inline void set_has_lastname();
  inline void clear_has_lastname();
  inline void set_has_phonenumber();
  inline void clear_has_phonenumber();
  inline void set_has_passport();
  inline void clear_has_passport();
  inline void set_has_role();
  inline void clear_has_role();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* login_;
  ::std::string* pass_;
  ::std::string* firstname_;
  ::std::string* secondname_;
  ::std::string* lastname_;
  ::std::string* phonenumber_;
  ::std::string* passport_;
  ::google::protobuf::int32 role_;
  friend void  protobuf_AddDesc_Message_2eproto();
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static RegisterMessage* default_instance_;
};
// -------------------------------------------------------------------

class RegisterEmployeeMessage : public ::google::protobuf::Message {
 public:
  RegisterEmployeeMessage();
  virtual ~RegisterEmployeeMessage();

  RegisterEmployeeMessage(const RegisterEmployeeMessage& from);

  inline RegisterEmployeeMessage& operator=(const RegisterEmployeeMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterEmployeeMessage& default_instance();

  void Swap(RegisterEmployeeMessage* other);

  // implements Message ----------------------------------------------

  RegisterEmployeeMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegisterEmployeeMessage& from);
  void MergeFrom(const RegisterEmployeeMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string login = 1;
  inline bool has_login() const;
  inline void clear_login();
  static const int kLoginFieldNumber = 1;
  inline const ::std::string& login() const;
  inline void set_login(const ::std::string& value);
  inline void set_login(const char* value);
  inline void set_login(const char* value, size_t size);
  inline ::std::string* mutable_login();
  inline ::std::string* release_login();
  inline void set_allocated_login(::std::string* login);

  // optional string pass = 2;
  inline bool has_pass() const;
  inline void clear_pass();
  static const int kPassFieldNumber = 2;
  inline const ::std::string& pass() const;
  inline void set_pass(const ::std::string& value);
  inline void set_pass(const char* value);
  inline void set_pass(const char* value, size_t size);
  inline ::std::string* mutable_pass();
  inline ::std::string* release_pass();
  inline void set_allocated_pass(::std::string* pass);

  // optional string firstname = 3;
  inline bool has_firstname() const;
  inline void clear_firstname();
  static const int kFirstnameFieldNumber = 3;
  inline const ::std::string& firstname() const;
  inline void set_firstname(const ::std::string& value);
  inline void set_firstname(const char* value);
  inline void set_firstname(const char* value, size_t size);
  inline ::std::string* mutable_firstname();
  inline ::std::string* release_firstname();
  inline void set_allocated_firstname(::std::string* firstname);

  // optional string secondname = 4;
  inline bool has_secondname() const;
  inline void clear_secondname();
  static const int kSecondnameFieldNumber = 4;
  inline const ::std::string& secondname() const;
  inline void set_secondname(const ::std::string& value);
  inline void set_secondname(const char* value);
  inline void set_secondname(const char* value, size_t size);
  inline ::std::string* mutable_secondname();
  inline ::std::string* release_secondname();
  inline void set_allocated_secondname(::std::string* secondname);

  // optional string lastname = 5;
  inline bool has_lastname() const;
  inline void clear_lastname();
  static const int kLastnameFieldNumber = 5;
  inline const ::std::string& lastname() const;
  inline void set_lastname(const ::std::string& value);
  inline void set_lastname(const char* value);
  inline void set_lastname(const char* value, size_t size);
  inline ::std::string* mutable_lastname();
  inline ::std::string* release_lastname();
  inline void set_allocated_lastname(::std::string* lastname);

  // optional string phonenumber = 6;
  inline bool has_phonenumber() const;
  inline void clear_phonenumber();
  static const int kPhonenumberFieldNumber = 6;
  inline const ::std::string& phonenumber() const;
  inline void set_phonenumber(const ::std::string& value);
  inline void set_phonenumber(const char* value);
  inline void set_phonenumber(const char* value, size_t size);
  inline ::std::string* mutable_phonenumber();
  inline ::std::string* release_phonenumber();
  inline void set_allocated_phonenumber(::std::string* phonenumber);

  // optional int32 salary = 7;
  inline bool has_salary() const;
  inline void clear_salary();
  static const int kSalaryFieldNumber = 7;
  inline ::google::protobuf::int32 salary() const;
  inline void set_salary(::google::protobuf::int32 value);

  // optional int32 position = 8;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 8;
  inline ::google::protobuf::int32 position() const;
  inline void set_position(::google::protobuf::int32 value);

  // optional int32 hotelId = 9;
  inline bool has_hotelid() const;
  inline void clear_hotelid();
  static const int kHotelIdFieldNumber = 9;
  inline ::google::protobuf::int32 hotelid() const;
  inline void set_hotelid(::google::protobuf::int32 value);

  // optional int32 role = 10;
  inline bool has_role() const;
  inline void clear_role();
  static const int kRoleFieldNumber = 10;
  inline ::google::protobuf::int32 role() const;
  inline void set_role(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:network.RegisterEmployeeMessage)
 private:
  inline void set_has_login();
  inline void clear_has_login();
  inline void set_has_pass();
  inline void clear_has_pass();
  inline void set_has_firstname();
  inline void clear_has_firstname();
  inline void set_has_secondname();
  inline void clear_has_secondname();
  inline void set_has_lastname();
  inline void clear_has_lastname();
  inline void set_has_phonenumber();
  inline void clear_has_phonenumber();
  inline void set_has_salary();
  inline void clear_has_salary();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_hotelid();
  inline void clear_has_hotelid();
  inline void set_has_role();
  inline void clear_has_role();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* login_;
  ::std::string* pass_;
  ::std::string* firstname_;
  ::std::string* secondname_;
  ::std::string* lastname_;
  ::std::string* phonenumber_;
  ::google::protobuf::int32 salary_;
  ::google::protobuf::int32 position_;
  ::google::protobuf::int32 hotelid_;
  ::google::protobuf::int32 role_;
  friend void  protobuf_AddDesc_Message_2eproto();
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static RegisterEmployeeMessage* default_instance_;
};
// -------------------------------------------------------------------

class GuestInfo : public ::google::protobuf::Message {
 public:
  GuestInfo();
  virtual ~GuestInfo();

  GuestInfo(const GuestInfo& from);

  inline GuestInfo& operator=(const GuestInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GuestInfo& default_instance();

  void Swap(GuestInfo* other);

  // implements Message ----------------------------------------------

  GuestInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GuestInfo& from);
  void MergeFrom(const GuestInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string firstname = 1;
  inline bool has_firstname() const;
  inline void clear_firstname();
  static const int kFirstnameFieldNumber = 1;
  inline const ::std::string& firstname() const;
  inline void set_firstname(const ::std::string& value);
  inline void set_firstname(const char* value);
  inline void set_firstname(const char* value, size_t size);
  inline ::std::string* mutable_firstname();
  inline ::std::string* release_firstname();
  inline void set_allocated_firstname(::std::string* firstname);

  // optional string secondname = 2;
  inline bool has_secondname() const;
  inline void clear_secondname();
  static const int kSecondnameFieldNumber = 2;
  inline const ::std::string& secondname() const;
  inline void set_secondname(const ::std::string& value);
  inline void set_secondname(const char* value);
  inline void set_secondname(const char* value, size_t size);
  inline ::std::string* mutable_secondname();
  inline ::std::string* release_secondname();
  inline void set_allocated_secondname(::std::string* secondname);

  // optional string lastname = 3;
  inline bool has_lastname() const;
  inline void clear_lastname();
  static const int kLastnameFieldNumber = 3;
  inline const ::std::string& lastname() const;
  inline void set_lastname(const ::std::string& value);
  inline void set_lastname(const char* value);
  inline void set_lastname(const char* value, size_t size);
  inline ::std::string* mutable_lastname();
  inline ::std::string* release_lastname();
  inline void set_allocated_lastname(::std::string* lastname);

  // optional string phonenumber = 4;
  inline bool has_phonenumber() const;
  inline void clear_phonenumber();
  static const int kPhonenumberFieldNumber = 4;
  inline const ::std::string& phonenumber() const;
  inline void set_phonenumber(const ::std::string& value);
  inline void set_phonenumber(const char* value);
  inline void set_phonenumber(const char* value, size_t size);
  inline ::std::string* mutable_phonenumber();
  inline ::std::string* release_phonenumber();
  inline void set_allocated_phonenumber(::std::string* phonenumber);

  // optional string passport = 5;
  inline bool has_passport() const;
  inline void clear_passport();
  static const int kPassportFieldNumber = 5;
  inline const ::std::string& passport() const;
  inline void set_passport(const ::std::string& value);
  inline void set_passport(const char* value);
  inline void set_passport(const char* value, size_t size);
  inline ::std::string* mutable_passport();
  inline ::std::string* release_passport();
  inline void set_allocated_passport(::std::string* passport);

  // optional int32 id = 6;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 6;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:network.GuestInfo)
 private:
  inline void set_has_firstname();
  inline void clear_has_firstname();
  inline void set_has_secondname();
  inline void clear_has_secondname();
  inline void set_has_lastname();
  inline void clear_has_lastname();
  inline void set_has_phonenumber();
  inline void clear_has_phonenumber();
  inline void set_has_passport();
  inline void clear_has_passport();
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* firstname_;
  ::std::string* secondname_;
  ::std::string* lastname_;
  ::std::string* phonenumber_;
  ::std::string* passport_;
  ::google::protobuf::int32 id_;
  friend void  protobuf_AddDesc_Message_2eproto();
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static GuestInfo* default_instance_;
};
// -------------------------------------------------------------------

class GuestsMessageResponse : public ::google::protobuf::Message {
 public:
  GuestsMessageResponse();
  virtual ~GuestsMessageResponse();

  GuestsMessageResponse(const GuestsMessageResponse& from);

  inline GuestsMessageResponse& operator=(const GuestsMessageResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GuestsMessageResponse& default_instance();

  void Swap(GuestsMessageResponse* other);

  // implements Message ----------------------------------------------

  GuestsMessageResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GuestsMessageResponse& from);
  void MergeFrom(const GuestsMessageResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .network.GuestInfo guests = 1;
  inline int guests_size() const;
  inline void clear_guests();
  static const int kGuestsFieldNumber = 1;
  inline const ::network::GuestInfo& guests(int index) const;
  inline ::network::GuestInfo* mutable_guests(int index);
  inline ::network::GuestInfo* add_guests();
  inline const ::google::protobuf::RepeatedPtrField< ::network::GuestInfo >&
      guests() const;
  inline ::google::protobuf::RepeatedPtrField< ::network::GuestInfo >*
      mutable_guests();

  // @@protoc_insertion_point(class_scope:network.GuestsMessageResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::network::GuestInfo > guests_;
  friend void  protobuf_AddDesc_Message_2eproto();
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static GuestsMessageResponse* default_instance_;
};
// -------------------------------------------------------------------

class EmployeeInfo : public ::google::protobuf::Message {
 public:
  EmployeeInfo();
  virtual ~EmployeeInfo();

  EmployeeInfo(const EmployeeInfo& from);

  inline EmployeeInfo& operator=(const EmployeeInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EmployeeInfo& default_instance();

  void Swap(EmployeeInfo* other);

  // implements Message ----------------------------------------------

  EmployeeInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EmployeeInfo& from);
  void MergeFrom(const EmployeeInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string firstname = 1;
  inline bool has_firstname() const;
  inline void clear_firstname();
  static const int kFirstnameFieldNumber = 1;
  inline const ::std::string& firstname() const;
  inline void set_firstname(const ::std::string& value);
  inline void set_firstname(const char* value);
  inline void set_firstname(const char* value, size_t size);
  inline ::std::string* mutable_firstname();
  inline ::std::string* release_firstname();
  inline void set_allocated_firstname(::std::string* firstname);

  // optional string secondname = 2;
  inline bool has_secondname() const;
  inline void clear_secondname();
  static const int kSecondnameFieldNumber = 2;
  inline const ::std::string& secondname() const;
  inline void set_secondname(const ::std::string& value);
  inline void set_secondname(const char* value);
  inline void set_secondname(const char* value, size_t size);
  inline ::std::string* mutable_secondname();
  inline ::std::string* release_secondname();
  inline void set_allocated_secondname(::std::string* secondname);

  // optional string lastname = 3;
  inline bool has_lastname() const;
  inline void clear_lastname();
  static const int kLastnameFieldNumber = 3;
  inline const ::std::string& lastname() const;
  inline void set_lastname(const ::std::string& value);
  inline void set_lastname(const char* value);
  inline void set_lastname(const char* value, size_t size);
  inline ::std::string* mutable_lastname();
  inline ::std::string* release_lastname();
  inline void set_allocated_lastname(::std::string* lastname);

  // optional string phonenumber = 4;
  inline bool has_phonenumber() const;
  inline void clear_phonenumber();
  static const int kPhonenumberFieldNumber = 4;
  inline const ::std::string& phonenumber() const;
  inline void set_phonenumber(const ::std::string& value);
  inline void set_phonenumber(const char* value);
  inline void set_phonenumber(const char* value, size_t size);
  inline ::std::string* mutable_phonenumber();
  inline ::std::string* release_phonenumber();
  inline void set_allocated_phonenumber(::std::string* phonenumber);

  // optional int32 salary = 5;
  inline bool has_salary() const;
  inline void clear_salary();
  static const int kSalaryFieldNumber = 5;
  inline ::google::protobuf::int32 salary() const;
  inline void set_salary(::google::protobuf::int32 value);

  // optional string position = 6;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 6;
  inline const ::std::string& position() const;
  inline void set_position(const ::std::string& value);
  inline void set_position(const char* value);
  inline void set_position(const char* value, size_t size);
  inline ::std::string* mutable_position();
  inline ::std::string* release_position();
  inline void set_allocated_position(::std::string* position);

  // optional int32 hotelId = 7;
  inline bool has_hotelid() const;
  inline void clear_hotelid();
  static const int kHotelIdFieldNumber = 7;
  inline ::google::protobuf::int32 hotelid() const;
  inline void set_hotelid(::google::protobuf::int32 value);

  // optional int32 id = 8;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 8;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:network.EmployeeInfo)
 private:
  inline void set_has_firstname();
  inline void clear_has_firstname();
  inline void set_has_secondname();
  inline void clear_has_secondname();
  inline void set_has_lastname();
  inline void clear_has_lastname();
  inline void set_has_phonenumber();
  inline void clear_has_phonenumber();
  inline void set_has_salary();
  inline void clear_has_salary();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_hotelid();
  inline void clear_has_hotelid();
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* firstname_;
  ::std::string* secondname_;
  ::std::string* lastname_;
  ::std::string* phonenumber_;
  ::std::string* position_;
  ::google::protobuf::int32 salary_;
  ::google::protobuf::int32 hotelid_;
  ::google::protobuf::int32 id_;
  friend void  protobuf_AddDesc_Message_2eproto();
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static EmployeeInfo* default_instance_;
};
// -------------------------------------------------------------------

class EmployeesMessageResponse : public ::google::protobuf::Message {
 public:
  EmployeesMessageResponse();
  virtual ~EmployeesMessageResponse();

  EmployeesMessageResponse(const EmployeesMessageResponse& from);

  inline EmployeesMessageResponse& operator=(const EmployeesMessageResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EmployeesMessageResponse& default_instance();

  void Swap(EmployeesMessageResponse* other);

  // implements Message ----------------------------------------------

  EmployeesMessageResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EmployeesMessageResponse& from);
  void MergeFrom(const EmployeesMessageResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .network.EmployeeInfo employees = 1;
  inline int employees_size() const;
  inline void clear_employees();
  static const int kEmployeesFieldNumber = 1;
  inline const ::network::EmployeeInfo& employees(int index) const;
  inline ::network::EmployeeInfo* mutable_employees(int index);
  inline ::network::EmployeeInfo* add_employees();
  inline const ::google::protobuf::RepeatedPtrField< ::network::EmployeeInfo >&
      employees() const;
  inline ::google::protobuf::RepeatedPtrField< ::network::EmployeeInfo >*
      mutable_employees();

  // @@protoc_insertion_point(class_scope:network.EmployeesMessageResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::network::EmployeeInfo > employees_;
  friend void  protobuf_AddDesc_Message_2eproto();
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static EmployeesMessageResponse* default_instance_;
};
// -------------------------------------------------------------------

class HotelId : public ::google::protobuf::Message {
 public:
  HotelId();
  virtual ~HotelId();

  HotelId(const HotelId& from);

  inline HotelId& operator=(const HotelId& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HotelId& default_instance();

  void Swap(HotelId* other);

  // implements Message ----------------------------------------------

  HotelId* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HotelId& from);
  void MergeFrom(const HotelId& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 hotelId = 1;
  inline bool has_hotelid() const;
  inline void clear_hotelid();
  static const int kHotelIdFieldNumber = 1;
  inline ::google::protobuf::int32 hotelid() const;
  inline void set_hotelid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:network.HotelId)
 private:
  inline void set_has_hotelid();
  inline void clear_has_hotelid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 hotelid_;
  friend void  protobuf_AddDesc_Message_2eproto();
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static HotelId* default_instance_;
};
// -------------------------------------------------------------------

class HotelInfo : public ::google::protobuf::Message {
 public:
  HotelInfo();
  virtual ~HotelInfo();

  HotelInfo(const HotelInfo& from);

  inline HotelInfo& operator=(const HotelInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HotelInfo& default_instance();

  void Swap(HotelInfo* other);

  // implements Message ----------------------------------------------

  HotelInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HotelInfo& from);
  void MergeFrom(const HotelInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string city = 2;
  inline bool has_city() const;
  inline void clear_city();
  static const int kCityFieldNumber = 2;
  inline const ::std::string& city() const;
  inline void set_city(const ::std::string& value);
  inline void set_city(const char* value);
  inline void set_city(const char* value, size_t size);
  inline ::std::string* mutable_city();
  inline ::std::string* release_city();
  inline void set_allocated_city(::std::string* city);

  // optional string street = 3;
  inline bool has_street() const;
  inline void clear_street();
  static const int kStreetFieldNumber = 3;
  inline const ::std::string& street() const;
  inline void set_street(const ::std::string& value);
  inline void set_street(const char* value);
  inline void set_street(const char* value, size_t size);
  inline ::std::string* mutable_street();
  inline ::std::string* release_street();
  inline void set_allocated_street(::std::string* street);

  // optional string phonenumber = 4;
  inline bool has_phonenumber() const;
  inline void clear_phonenumber();
  static const int kPhonenumberFieldNumber = 4;
  inline const ::std::string& phonenumber() const;
  inline void set_phonenumber(const ::std::string& value);
  inline void set_phonenumber(const char* value);
  inline void set_phonenumber(const char* value, size_t size);
  inline ::std::string* mutable_phonenumber();
  inline ::std::string* release_phonenumber();
  inline void set_allocated_phonenumber(::std::string* phonenumber);

  // optional string email = 5;
  inline bool has_email() const;
  inline void clear_email();
  static const int kEmailFieldNumber = 5;
  inline const ::std::string& email() const;
  inline void set_email(const ::std::string& value);
  inline void set_email(const char* value);
  inline void set_email(const char* value, size_t size);
  inline ::std::string* mutable_email();
  inline ::std::string* release_email();
  inline void set_allocated_email(::std::string* email);

  // optional int32 stars = 6;
  inline bool has_stars() const;
  inline void clear_stars();
  static const int kStarsFieldNumber = 6;
  inline ::google::protobuf::int32 stars() const;
  inline void set_stars(::google::protobuf::int32 value);

  // optional string type = 7;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 7;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // @@protoc_insertion_point(class_scope:network.HotelInfo)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_city();
  inline void clear_has_city();
  inline void set_has_street();
  inline void clear_has_street();
  inline void set_has_phonenumber();
  inline void clear_has_phonenumber();
  inline void set_has_email();
  inline void clear_has_email();
  inline void set_has_stars();
  inline void clear_has_stars();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::std::string* city_;
  ::std::string* street_;
  ::std::string* phonenumber_;
  ::std::string* email_;
  ::std::string* type_;
  ::google::protobuf::int32 stars_;
  friend void  protobuf_AddDesc_Message_2eproto();
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static HotelInfo* default_instance_;
};
// -------------------------------------------------------------------

class HotelsMessageResponse : public ::google::protobuf::Message {
 public:
  HotelsMessageResponse();
  virtual ~HotelsMessageResponse();

  HotelsMessageResponse(const HotelsMessageResponse& from);

  inline HotelsMessageResponse& operator=(const HotelsMessageResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HotelsMessageResponse& default_instance();

  void Swap(HotelsMessageResponse* other);

  // implements Message ----------------------------------------------

  HotelsMessageResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HotelsMessageResponse& from);
  void MergeFrom(const HotelsMessageResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .network.HotelInfo hotels = 1;
  inline int hotels_size() const;
  inline void clear_hotels();
  static const int kHotelsFieldNumber = 1;
  inline const ::network::HotelInfo& hotels(int index) const;
  inline ::network::HotelInfo* mutable_hotels(int index);
  inline ::network::HotelInfo* add_hotels();
  inline const ::google::protobuf::RepeatedPtrField< ::network::HotelInfo >&
      hotels() const;
  inline ::google::protobuf::RepeatedPtrField< ::network::HotelInfo >*
      mutable_hotels();

  // @@protoc_insertion_point(class_scope:network.HotelsMessageResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::network::HotelInfo > hotels_;
  friend void  protobuf_AddDesc_Message_2eproto();
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static HotelsMessageResponse* default_instance_;
};
// -------------------------------------------------------------------

class RoomInfo : public ::google::protobuf::Message {
 public:
  RoomInfo();
  virtual ~RoomInfo();

  RoomInfo(const RoomInfo& from);

  inline RoomInfo& operator=(const RoomInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomInfo& default_instance();

  void Swap(RoomInfo* other);

  // implements Message ----------------------------------------------

  RoomInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoomInfo& from);
  void MergeFrom(const RoomInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 places = 1;
  inline bool has_places() const;
  inline void clear_places();
  static const int kPlacesFieldNumber = 1;
  inline ::google::protobuf::int32 places() const;
  inline void set_places(::google::protobuf::int32 value);

  // optional int32 price = 2;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 2;
  inline ::google::protobuf::int32 price() const;
  inline void set_price(::google::protobuf::int32 value);

  // optional int32 rating = 3;
  inline bool has_rating() const;
  inline void clear_rating();
  static const int kRatingFieldNumber = 3;
  inline ::google::protobuf::int32 rating() const;
  inline void set_rating(::google::protobuf::int32 value);

  // optional bool status = 4;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 4;
  inline bool status() const;
  inline void set_status(bool value);

  // optional int32 floor = 5;
  inline bool has_floor() const;
  inline void clear_floor();
  static const int kFloorFieldNumber = 5;
  inline ::google::protobuf::int32 floor() const;
  inline void set_floor(::google::protobuf::int32 value);

  // optional string type = 6;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 6;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // optional int32 hotelID = 7;
  inline bool has_hotelid() const;
  inline void clear_hotelid();
  static const int kHotelIDFieldNumber = 7;
  inline ::google::protobuf::int32 hotelid() const;
  inline void set_hotelid(::google::protobuf::int32 value);

  // optional int32 id = 8;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 8;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:network.RoomInfo)
 private:
  inline void set_has_places();
  inline void clear_has_places();
  inline void set_has_price();
  inline void clear_has_price();
  inline void set_has_rating();
  inline void clear_has_rating();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_floor();
  inline void clear_has_floor();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_hotelid();
  inline void clear_has_hotelid();
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 places_;
  ::google::protobuf::int32 price_;
  ::google::protobuf::int32 rating_;
  bool status_;
  ::std::string* type_;
  ::google::protobuf::int32 floor_;
  ::google::protobuf::int32 hotelid_;
  ::google::protobuf::int32 id_;
  friend void  protobuf_AddDesc_Message_2eproto();
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static RoomInfo* default_instance_;
};
// -------------------------------------------------------------------

class RoomsMessageResponse : public ::google::protobuf::Message {
 public:
  RoomsMessageResponse();
  virtual ~RoomsMessageResponse();

  RoomsMessageResponse(const RoomsMessageResponse& from);

  inline RoomsMessageResponse& operator=(const RoomsMessageResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomsMessageResponse& default_instance();

  void Swap(RoomsMessageResponse* other);

  // implements Message ----------------------------------------------

  RoomsMessageResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoomsMessageResponse& from);
  void MergeFrom(const RoomsMessageResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .network.RoomInfo rooms = 1;
  inline int rooms_size() const;
  inline void clear_rooms();
  static const int kRoomsFieldNumber = 1;
  inline const ::network::RoomInfo& rooms(int index) const;
  inline ::network::RoomInfo* mutable_rooms(int index);
  inline ::network::RoomInfo* add_rooms();
  inline const ::google::protobuf::RepeatedPtrField< ::network::RoomInfo >&
      rooms() const;
  inline ::google::protobuf::RepeatedPtrField< ::network::RoomInfo >*
      mutable_rooms();

  // @@protoc_insertion_point(class_scope:network.RoomsMessageResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::network::RoomInfo > rooms_;
  friend void  protobuf_AddDesc_Message_2eproto();
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static RoomsMessageResponse* default_instance_;
};
// -------------------------------------------------------------------

class VacantRooms : public ::google::protobuf::Message {
 public:
  VacantRooms();
  virtual ~VacantRooms();

  VacantRooms(const VacantRooms& from);

  inline VacantRooms& operator=(const VacantRooms& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VacantRooms& default_instance();

  void Swap(VacantRooms* other);

  // implements Message ----------------------------------------------

  VacantRooms* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VacantRooms& from);
  void MergeFrom(const VacantRooms& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 places = 1;
  inline bool has_places() const;
  inline void clear_places();
  static const int kPlacesFieldNumber = 1;
  inline ::google::protobuf::int32 places() const;
  inline void set_places(::google::protobuf::int32 value);

  // optional int32 begin_price = 2;
  inline bool has_begin_price() const;
  inline void clear_begin_price();
  static const int kBeginPriceFieldNumber = 2;
  inline ::google::protobuf::int32 begin_price() const;
  inline void set_begin_price(::google::protobuf::int32 value);

  // optional int32 end_price = 3;
  inline bool has_end_price() const;
  inline void clear_end_price();
  static const int kEndPriceFieldNumber = 3;
  inline ::google::protobuf::int32 end_price() const;
  inline void set_end_price(::google::protobuf::int32 value);

  // optional string datebegin = 5;
  inline bool has_datebegin() const;
  inline void clear_datebegin();
  static const int kDatebeginFieldNumber = 5;
  inline const ::std::string& datebegin() const;
  inline void set_datebegin(const ::std::string& value);
  inline void set_datebegin(const char* value);
  inline void set_datebegin(const char* value, size_t size);
  inline ::std::string* mutable_datebegin();
  inline ::std::string* release_datebegin();
  inline void set_allocated_datebegin(::std::string* datebegin);

  // optional string dateend = 6;
  inline bool has_dateend() const;
  inline void clear_dateend();
  static const int kDateendFieldNumber = 6;
  inline const ::std::string& dateend() const;
  inline void set_dateend(const ::std::string& value);
  inline void set_dateend(const char* value);
  inline void set_dateend(const char* value, size_t size);
  inline ::std::string* mutable_dateend();
  inline ::std::string* release_dateend();
  inline void set_allocated_dateend(::std::string* dateend);

  // optional int32 hotelID = 7;
  inline bool has_hotelid() const;
  inline void clear_hotelid();
  static const int kHotelIDFieldNumber = 7;
  inline ::google::protobuf::int32 hotelid() const;
  inline void set_hotelid(::google::protobuf::int32 value);

  // optional int32 begin_rating = 8;
  inline bool has_begin_rating() const;
  inline void clear_begin_rating();
  static const int kBeginRatingFieldNumber = 8;
  inline ::google::protobuf::int32 begin_rating() const;
  inline void set_begin_rating(::google::protobuf::int32 value);

  // optional int32 end_rating = 9;
  inline bool has_end_rating() const;
  inline void clear_end_rating();
  static const int kEndRatingFieldNumber = 9;
  inline ::google::protobuf::int32 end_rating() const;
  inline void set_end_rating(::google::protobuf::int32 value);

  // optional string room_type = 10;
  inline bool has_room_type() const;
  inline void clear_room_type();
  static const int kRoomTypeFieldNumber = 10;
  inline const ::std::string& room_type() const;
  inline void set_room_type(const ::std::string& value);
  inline void set_room_type(const char* value);
  inline void set_room_type(const char* value, size_t size);
  inline ::std::string* mutable_room_type();
  inline ::std::string* release_room_type();
  inline void set_allocated_room_type(::std::string* room_type);

  // @@protoc_insertion_point(class_scope:network.VacantRooms)
 private:
  inline void set_has_places();
  inline void clear_has_places();
  inline void set_has_begin_price();
  inline void clear_has_begin_price();
  inline void set_has_end_price();
  inline void clear_has_end_price();
  inline void set_has_datebegin();
  inline void clear_has_datebegin();
  inline void set_has_dateend();
  inline void clear_has_dateend();
  inline void set_has_hotelid();
  inline void clear_has_hotelid();
  inline void set_has_begin_rating();
  inline void clear_has_begin_rating();
  inline void set_has_end_rating();
  inline void clear_has_end_rating();
  inline void set_has_room_type();
  inline void clear_has_room_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 places_;
  ::google::protobuf::int32 begin_price_;
  ::std::string* datebegin_;
  ::google::protobuf::int32 end_price_;
  ::google::protobuf::int32 hotelid_;
  ::std::string* dateend_;
  ::google::protobuf::int32 begin_rating_;
  ::google::protobuf::int32 end_rating_;
  ::std::string* room_type_;
  friend void  protobuf_AddDesc_Message_2eproto();
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static VacantRooms* default_instance_;
};
// -------------------------------------------------------------------

class OrderInfo : public ::google::protobuf::Message {
 public:
  OrderInfo();
  virtual ~OrderInfo();

  OrderInfo(const OrderInfo& from);

  inline OrderInfo& operator=(const OrderInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OrderInfo& default_instance();

  void Swap(OrderInfo* other);

  // implements Message ----------------------------------------------

  OrderInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OrderInfo& from);
  void MergeFrom(const OrderInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional string startdate = 2;
  inline bool has_startdate() const;
  inline void clear_startdate();
  static const int kStartdateFieldNumber = 2;
  inline const ::std::string& startdate() const;
  inline void set_startdate(const ::std::string& value);
  inline void set_startdate(const char* value);
  inline void set_startdate(const char* value, size_t size);
  inline ::std::string* mutable_startdate();
  inline ::std::string* release_startdate();
  inline void set_allocated_startdate(::std::string* startdate);

  // optional string enddate = 3;
  inline bool has_enddate() const;
  inline void clear_enddate();
  static const int kEnddateFieldNumber = 3;
  inline const ::std::string& enddate() const;
  inline void set_enddate(const ::std::string& value);
  inline void set_enddate(const char* value);
  inline void set_enddate(const char* value, size_t size);
  inline ::std::string* mutable_enddate();
  inline ::std::string* release_enddate();
  inline void set_allocated_enddate(::std::string* enddate);

  // optional int32 idroom = 4;
  inline bool has_idroom() const;
  inline void clear_idroom();
  static const int kIdroomFieldNumber = 4;
  inline ::google::protobuf::int32 idroom() const;
  inline void set_idroom(::google::protobuf::int32 value);

  // optional string employee_secondname = 5;
  inline bool has_employee_secondname() const;
  inline void clear_employee_secondname();
  static const int kEmployeeSecondnameFieldNumber = 5;
  inline const ::std::string& employee_secondname() const;
  inline void set_employee_secondname(const ::std::string& value);
  inline void set_employee_secondname(const char* value);
  inline void set_employee_secondname(const char* value, size_t size);
  inline ::std::string* mutable_employee_secondname();
  inline ::std::string* release_employee_secondname();
  inline void set_allocated_employee_secondname(::std::string* employee_secondname);

  // optional string guest_secondname = 6;
  inline bool has_guest_secondname() const;
  inline void clear_guest_secondname();
  static const int kGuestSecondnameFieldNumber = 6;
  inline const ::std::string& guest_secondname() const;
  inline void set_guest_secondname(const ::std::string& value);
  inline void set_guest_secondname(const char* value);
  inline void set_guest_secondname(const char* value, size_t size);
  inline ::std::string* mutable_guest_secondname();
  inline ::std::string* release_guest_secondname();
  inline void set_allocated_guest_secondname(::std::string* guest_secondname);

  // optional int32 hotelID = 7;
  inline bool has_hotelid() const;
  inline void clear_hotelid();
  static const int kHotelIDFieldNumber = 7;
  inline ::google::protobuf::int32 hotelid() const;
  inline void set_hotelid(::google::protobuf::int32 value);

  // optional int32 employee_id = 8;
  inline bool has_employee_id() const;
  inline void clear_employee_id();
  static const int kEmployeeIdFieldNumber = 8;
  inline ::google::protobuf::int32 employee_id() const;
  inline void set_employee_id(::google::protobuf::int32 value);

  // optional int32 guest_id = 9;
  inline bool has_guest_id() const;
  inline void clear_guest_id();
  static const int kGuestIdFieldNumber = 9;
  inline ::google::protobuf::int32 guest_id() const;
  inline void set_guest_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:network.OrderInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_startdate();
  inline void clear_has_startdate();
  inline void set_has_enddate();
  inline void clear_has_enddate();
  inline void set_has_idroom();
  inline void clear_has_idroom();
  inline void set_has_employee_secondname();
  inline void clear_has_employee_secondname();
  inline void set_has_guest_secondname();
  inline void clear_has_guest_secondname();
  inline void set_has_hotelid();
  inline void clear_has_hotelid();
  inline void set_has_employee_id();
  inline void clear_has_employee_id();
  inline void set_has_guest_id();
  inline void clear_has_guest_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* startdate_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 idroom_;
  ::std::string* enddate_;
  ::std::string* employee_secondname_;
  ::std::string* guest_secondname_;
  ::google::protobuf::int32 hotelid_;
  ::google::protobuf::int32 employee_id_;
  ::google::protobuf::int32 guest_id_;
  friend void  protobuf_AddDesc_Message_2eproto();
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static OrderInfo* default_instance_;
};
// -------------------------------------------------------------------

class OrdersMessageResponse : public ::google::protobuf::Message {
 public:
  OrdersMessageResponse();
  virtual ~OrdersMessageResponse();

  OrdersMessageResponse(const OrdersMessageResponse& from);

  inline OrdersMessageResponse& operator=(const OrdersMessageResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OrdersMessageResponse& default_instance();

  void Swap(OrdersMessageResponse* other);

  // implements Message ----------------------------------------------

  OrdersMessageResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OrdersMessageResponse& from);
  void MergeFrom(const OrdersMessageResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .network.OrderInfo orders = 1;
  inline int orders_size() const;
  inline void clear_orders();
  static const int kOrdersFieldNumber = 1;
  inline const ::network::OrderInfo& orders(int index) const;
  inline ::network::OrderInfo* mutable_orders(int index);
  inline ::network::OrderInfo* add_orders();
  inline const ::google::protobuf::RepeatedPtrField< ::network::OrderInfo >&
      orders() const;
  inline ::google::protobuf::RepeatedPtrField< ::network::OrderInfo >*
      mutable_orders();

  // @@protoc_insertion_point(class_scope:network.OrdersMessageResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::network::OrderInfo > orders_;
  friend void  protobuf_AddDesc_Message_2eproto();
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static OrdersMessageResponse* default_instance_;
};
// -------------------------------------------------------------------

class GuestOrderInfo : public ::google::protobuf::Message {
 public:
  GuestOrderInfo();
  virtual ~GuestOrderInfo();

  GuestOrderInfo(const GuestOrderInfo& from);

  inline GuestOrderInfo& operator=(const GuestOrderInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GuestOrderInfo& default_instance();

  void Swap(GuestOrderInfo* other);

  // implements Message ----------------------------------------------

  GuestOrderInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GuestOrderInfo& from);
  void MergeFrom(const GuestOrderInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string startdate = 1;
  inline bool has_startdate() const;
  inline void clear_startdate();
  static const int kStartdateFieldNumber = 1;
  inline const ::std::string& startdate() const;
  inline void set_startdate(const ::std::string& value);
  inline void set_startdate(const char* value);
  inline void set_startdate(const char* value, size_t size);
  inline ::std::string* mutable_startdate();
  inline ::std::string* release_startdate();
  inline void set_allocated_startdate(::std::string* startdate);

  // optional string enddate = 2;
  inline bool has_enddate() const;
  inline void clear_enddate();
  static const int kEnddateFieldNumber = 2;
  inline const ::std::string& enddate() const;
  inline void set_enddate(const ::std::string& value);
  inline void set_enddate(const char* value);
  inline void set_enddate(const char* value, size_t size);
  inline ::std::string* mutable_enddate();
  inline ::std::string* release_enddate();
  inline void set_allocated_enddate(::std::string* enddate);

  // optional int32 idroom = 3;
  inline bool has_idroom() const;
  inline void clear_idroom();
  static const int kIdroomFieldNumber = 3;
  inline ::google::protobuf::int32 idroom() const;
  inline void set_idroom(::google::protobuf::int32 value);

  // optional string guest_firstname = 4;
  inline bool has_guest_firstname() const;
  inline void clear_guest_firstname();
  static const int kGuestFirstnameFieldNumber = 4;
  inline const ::std::string& guest_firstname() const;
  inline void set_guest_firstname(const ::std::string& value);
  inline void set_guest_firstname(const char* value);
  inline void set_guest_firstname(const char* value, size_t size);
  inline ::std::string* mutable_guest_firstname();
  inline ::std::string* release_guest_firstname();
  inline void set_allocated_guest_firstname(::std::string* guest_firstname);

  // optional string guest_secondname = 5;
  inline bool has_guest_secondname() const;
  inline void clear_guest_secondname();
  static const int kGuestSecondnameFieldNumber = 5;
  inline const ::std::string& guest_secondname() const;
  inline void set_guest_secondname(const ::std::string& value);
  inline void set_guest_secondname(const char* value);
  inline void set_guest_secondname(const char* value, size_t size);
  inline ::std::string* mutable_guest_secondname();
  inline ::std::string* release_guest_secondname();
  inline void set_allocated_guest_secondname(::std::string* guest_secondname);

  // optional string guest_lastname = 6;
  inline bool has_guest_lastname() const;
  inline void clear_guest_lastname();
  static const int kGuestLastnameFieldNumber = 6;
  inline const ::std::string& guest_lastname() const;
  inline void set_guest_lastname(const ::std::string& value);
  inline void set_guest_lastname(const char* value);
  inline void set_guest_lastname(const char* value, size_t size);
  inline ::std::string* mutable_guest_lastname();
  inline ::std::string* release_guest_lastname();
  inline void set_allocated_guest_lastname(::std::string* guest_lastname);

  // @@protoc_insertion_point(class_scope:network.GuestOrderInfo)
 private:
  inline void set_has_startdate();
  inline void clear_has_startdate();
  inline void set_has_enddate();
  inline void clear_has_enddate();
  inline void set_has_idroom();
  inline void clear_has_idroom();
  inline void set_has_guest_firstname();
  inline void clear_has_guest_firstname();
  inline void set_has_guest_secondname();
  inline void clear_has_guest_secondname();
  inline void set_has_guest_lastname();
  inline void clear_has_guest_lastname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* startdate_;
  ::std::string* enddate_;
  ::std::string* guest_firstname_;
  ::std::string* guest_secondname_;
  ::std::string* guest_lastname_;
  ::google::protobuf::int32 idroom_;
  friend void  protobuf_AddDesc_Message_2eproto();
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static GuestOrderInfo* default_instance_;
};
// -------------------------------------------------------------------

class GuestOrdersMessageResponse : public ::google::protobuf::Message {
 public:
  GuestOrdersMessageResponse();
  virtual ~GuestOrdersMessageResponse();

  GuestOrdersMessageResponse(const GuestOrdersMessageResponse& from);

  inline GuestOrdersMessageResponse& operator=(const GuestOrdersMessageResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GuestOrdersMessageResponse& default_instance();

  void Swap(GuestOrdersMessageResponse* other);

  // implements Message ----------------------------------------------

  GuestOrdersMessageResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GuestOrdersMessageResponse& from);
  void MergeFrom(const GuestOrdersMessageResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .network.GuestOrderInfo orders = 1;
  inline int orders_size() const;
  inline void clear_orders();
  static const int kOrdersFieldNumber = 1;
  inline const ::network::GuestOrderInfo& orders(int index) const;
  inline ::network::GuestOrderInfo* mutable_orders(int index);
  inline ::network::GuestOrderInfo* add_orders();
  inline const ::google::protobuf::RepeatedPtrField< ::network::GuestOrderInfo >&
      orders() const;
  inline ::google::protobuf::RepeatedPtrField< ::network::GuestOrderInfo >*
      mutable_orders();

  // @@protoc_insertion_point(class_scope:network.GuestOrdersMessageResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::network::GuestOrderInfo > orders_;
  friend void  protobuf_AddDesc_Message_2eproto();
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static GuestOrdersMessageResponse* default_instance_;
};
// -------------------------------------------------------------------

class MakeOrderInfo : public ::google::protobuf::Message {
 public:
  MakeOrderInfo();
  virtual ~MakeOrderInfo();

  MakeOrderInfo(const MakeOrderInfo& from);

  inline MakeOrderInfo& operator=(const MakeOrderInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MakeOrderInfo& default_instance();

  void Swap(MakeOrderInfo* other);

  // implements Message ----------------------------------------------

  MakeOrderInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MakeOrderInfo& from);
  void MergeFrom(const MakeOrderInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string startdate = 1;
  inline bool has_startdate() const;
  inline void clear_startdate();
  static const int kStartdateFieldNumber = 1;
  inline const ::std::string& startdate() const;
  inline void set_startdate(const ::std::string& value);
  inline void set_startdate(const char* value);
  inline void set_startdate(const char* value, size_t size);
  inline ::std::string* mutable_startdate();
  inline ::std::string* release_startdate();
  inline void set_allocated_startdate(::std::string* startdate);

  // optional string enddate = 2;
  inline bool has_enddate() const;
  inline void clear_enddate();
  static const int kEnddateFieldNumber = 2;
  inline const ::std::string& enddate() const;
  inline void set_enddate(const ::std::string& value);
  inline void set_enddate(const char* value);
  inline void set_enddate(const char* value, size_t size);
  inline ::std::string* mutable_enddate();
  inline ::std::string* release_enddate();
  inline void set_allocated_enddate(::std::string* enddate);

  // optional int32 idroom = 3;
  inline bool has_idroom() const;
  inline void clear_idroom();
  static const int kIdroomFieldNumber = 3;
  inline ::google::protobuf::int32 idroom() const;
  inline void set_idroom(::google::protobuf::int32 value);

  // optional int32 idemployee = 4;
  inline bool has_idemployee() const;
  inline void clear_idemployee();
  static const int kIdemployeeFieldNumber = 4;
  inline ::google::protobuf::int32 idemployee() const;
  inline void set_idemployee(::google::protobuf::int32 value);

  // optional int32 idguest = 5;
  inline bool has_idguest() const;
  inline void clear_idguest();
  static const int kIdguestFieldNumber = 5;
  inline ::google::protobuf::int32 idguest() const;
  inline void set_idguest(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:network.MakeOrderInfo)
 private:
  inline void set_has_startdate();
  inline void clear_has_startdate();
  inline void set_has_enddate();
  inline void clear_has_enddate();
  inline void set_has_idroom();
  inline void clear_has_idroom();
  inline void set_has_idemployee();
  inline void clear_has_idemployee();
  inline void set_has_idguest();
  inline void clear_has_idguest();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* startdate_;
  ::std::string* enddate_;
  ::google::protobuf::int32 idroom_;
  ::google::protobuf::int32 idemployee_;
  ::google::protobuf::int32 idguest_;
  friend void  protobuf_AddDesc_Message_2eproto();
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static MakeOrderInfo* default_instance_;
};
// -------------------------------------------------------------------

class RequestContext : public ::google::protobuf::Message {
 public:
  RequestContext();
  virtual ~RequestContext();

  RequestContext(const RequestContext& from);

  inline RequestContext& operator=(const RequestContext& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestContext& default_instance();

  void Swap(RequestContext* other);

  // implements Message ----------------------------------------------

  RequestContext* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestContext& from);
  void MergeFrom(const RequestContext& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .network.message_type message_type_ = 1;
  inline bool has_message_type_() const;
  inline void clear_message_type_();
  static const int kMessageTypeFieldNumber = 1;
  inline ::network::message_type message_type_() const;
  inline void set_message_type_(::network::message_type value);

  // optional .network.AuthMessage auth_message_ = 2;
  inline bool has_auth_message_() const;
  inline void clear_auth_message_();
  static const int kAuthMessageFieldNumber = 2;
  inline const ::network::AuthMessage& auth_message_() const;
  inline ::network::AuthMessage* mutable_auth_message_();
  inline ::network::AuthMessage* release_auth_message_();
  inline void set_allocated_auth_message_(::network::AuthMessage* auth_message_);

  // optional .network.RegisterMessage register_message_ = 3;
  inline bool has_register_message_() const;
  inline void clear_register_message_();
  static const int kRegisterMessageFieldNumber = 3;
  inline const ::network::RegisterMessage& register_message_() const;
  inline ::network::RegisterMessage* mutable_register_message_();
  inline ::network::RegisterMessage* release_register_message_();
  inline void set_allocated_register_message_(::network::RegisterMessage* register_message_);

  // optional .network.RegisterEmployeeMessage register_employee_message_ = 4;
  inline bool has_register_employee_message_() const;
  inline void clear_register_employee_message_();
  static const int kRegisterEmployeeMessageFieldNumber = 4;
  inline const ::network::RegisterEmployeeMessage& register_employee_message_() const;
  inline ::network::RegisterEmployeeMessage* mutable_register_employee_message_();
  inline ::network::RegisterEmployeeMessage* release_register_employee_message_();
  inline void set_allocated_register_employee_message_(::network::RegisterEmployeeMessage* register_employee_message_);

  // optional .network.SessionInfo session_info = 5;
  inline bool has_session_info() const;
  inline void clear_session_info();
  static const int kSessionInfoFieldNumber = 5;
  inline const ::network::SessionInfo& session_info() const;
  inline ::network::SessionInfo* mutable_session_info();
  inline ::network::SessionInfo* release_session_info();
  inline void set_allocated_session_info(::network::SessionInfo* session_info);

  // optional .network.HotelId hotel_id = 6;
  inline bool has_hotel_id() const;
  inline void clear_hotel_id();
  static const int kHotelIdFieldNumber = 6;
  inline const ::network::HotelId& hotel_id() const;
  inline ::network::HotelId* mutable_hotel_id();
  inline ::network::HotelId* release_hotel_id();
  inline void set_allocated_hotel_id(::network::HotelId* hotel_id);

  // optional .network.EmployeeInfo employee_info = 7;
  inline bool has_employee_info() const;
  inline void clear_employee_info();
  static const int kEmployeeInfoFieldNumber = 7;
  inline const ::network::EmployeeInfo& employee_info() const;
  inline ::network::EmployeeInfo* mutable_employee_info();
  inline ::network::EmployeeInfo* release_employee_info();
  inline void set_allocated_employee_info(::network::EmployeeInfo* employee_info);

  // optional .network.RoomInfo room_info = 8;
  inline bool has_room_info() const;
  inline void clear_room_info();
  static const int kRoomInfoFieldNumber = 8;
  inline const ::network::RoomInfo& room_info() const;
  inline ::network::RoomInfo* mutable_room_info();
  inline ::network::RoomInfo* release_room_info();
  inline void set_allocated_room_info(::network::RoomInfo* room_info);

  // optional .network.VacantRooms data = 9;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 9;
  inline const ::network::VacantRooms& data() const;
  inline ::network::VacantRooms* mutable_data();
  inline ::network::VacantRooms* release_data();
  inline void set_allocated_data(::network::VacantRooms* data);

  // optional .network.MakeOrderInfo make_order_info = 10;
  inline bool has_make_order_info() const;
  inline void clear_make_order_info();
  static const int kMakeOrderInfoFieldNumber = 10;
  inline const ::network::MakeOrderInfo& make_order_info() const;
  inline ::network::MakeOrderInfo* mutable_make_order_info();
  inline ::network::MakeOrderInfo* release_make_order_info();
  inline void set_allocated_make_order_info(::network::MakeOrderInfo* make_order_info);

  // @@protoc_insertion_point(class_scope:network.RequestContext)
 private:
  inline void set_has_message_type_();
  inline void clear_has_message_type_();
  inline void set_has_auth_message_();
  inline void clear_has_auth_message_();
  inline void set_has_register_message_();
  inline void clear_has_register_message_();
  inline void set_has_register_employee_message_();
  inline void clear_has_register_employee_message_();
  inline void set_has_session_info();
  inline void clear_has_session_info();
  inline void set_has_hotel_id();
  inline void clear_has_hotel_id();
  inline void set_has_employee_info();
  inline void clear_has_employee_info();
  inline void set_has_room_info();
  inline void clear_has_room_info();
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_make_order_info();
  inline void clear_has_make_order_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::network::AuthMessage* auth_message__;
  ::network::RegisterMessage* register_message__;
  ::network::RegisterEmployeeMessage* register_employee_message__;
  ::network::SessionInfo* session_info_;
  ::network::HotelId* hotel_id_;
  ::network::EmployeeInfo* employee_info_;
  ::network::RoomInfo* room_info_;
  ::network::VacantRooms* data_;
  ::network::MakeOrderInfo* make_order_info_;
  int message_type__;
  friend void  protobuf_AddDesc_Message_2eproto();
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static RequestContext* default_instance_;
};
// -------------------------------------------------------------------

class RegisterMessageResponse : public ::google::protobuf::Message {
 public:
  RegisterMessageResponse();
  virtual ~RegisterMessageResponse();

  RegisterMessageResponse(const RegisterMessageResponse& from);

  inline RegisterMessageResponse& operator=(const RegisterMessageResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterMessageResponse& default_instance();

  void Swap(RegisterMessageResponse* other);

  // implements Message ----------------------------------------------

  RegisterMessageResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegisterMessageResponse& from);
  void MergeFrom(const RegisterMessageResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string messageText = 1;
  inline bool has_messagetext() const;
  inline void clear_messagetext();
  static const int kMessageTextFieldNumber = 1;
  inline const ::std::string& messagetext() const;
  inline void set_messagetext(const ::std::string& value);
  inline void set_messagetext(const char* value);
  inline void set_messagetext(const char* value, size_t size);
  inline ::std::string* mutable_messagetext();
  inline ::std::string* release_messagetext();
  inline void set_allocated_messagetext(::std::string* messagetext);

  // optional bool status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline bool status() const;
  inline void set_status(bool value);

  // @@protoc_insertion_point(class_scope:network.RegisterMessageResponse)
 private:
  inline void set_has_messagetext();
  inline void clear_has_messagetext();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* messagetext_;
  bool status_;
  friend void  protobuf_AddDesc_Message_2eproto();
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static RegisterMessageResponse* default_instance_;
};
// -------------------------------------------------------------------

class AuthMessageResponse : public ::google::protobuf::Message {
 public:
  AuthMessageResponse();
  virtual ~AuthMessageResponse();

  AuthMessageResponse(const AuthMessageResponse& from);

  inline AuthMessageResponse& operator=(const AuthMessageResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AuthMessageResponse& default_instance();

  void Swap(AuthMessageResponse* other);

  // implements Message ----------------------------------------------

  AuthMessageResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AuthMessageResponse& from);
  void MergeFrom(const AuthMessageResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 role = 1;
  inline bool has_role() const;
  inline void clear_role();
  static const int kRoleFieldNumber = 1;
  inline ::google::protobuf::int32 role() const;
  inline void set_role(::google::protobuf::int32 value);

  // optional int32 id_hotel = 2;
  inline bool has_id_hotel() const;
  inline void clear_id_hotel();
  static const int kIdHotelFieldNumber = 2;
  inline ::google::protobuf::int32 id_hotel() const;
  inline void set_id_hotel(::google::protobuf::int32 value);

  // optional bool status = 3;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 3;
  inline bool status() const;
  inline void set_status(bool value);

  // optional string messageText = 4;
  inline bool has_messagetext() const;
  inline void clear_messagetext();
  static const int kMessageTextFieldNumber = 4;
  inline const ::std::string& messagetext() const;
  inline void set_messagetext(const ::std::string& value);
  inline void set_messagetext(const char* value);
  inline void set_messagetext(const char* value, size_t size);
  inline ::std::string* mutable_messagetext();
  inline ::std::string* release_messagetext();
  inline void set_allocated_messagetext(::std::string* messagetext);

  // optional int32 id_user = 5;
  inline bool has_id_user() const;
  inline void clear_id_user();
  static const int kIdUserFieldNumber = 5;
  inline ::google::protobuf::int32 id_user() const;
  inline void set_id_user(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:network.AuthMessageResponse)
 private:
  inline void set_has_role();
  inline void clear_has_role();
  inline void set_has_id_hotel();
  inline void clear_has_id_hotel();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_messagetext();
  inline void clear_has_messagetext();
  inline void set_has_id_user();
  inline void clear_has_id_user();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 role_;
  ::google::protobuf::int32 id_hotel_;
  ::std::string* messagetext_;
  bool status_;
  ::google::protobuf::int32 id_user_;
  friend void  protobuf_AddDesc_Message_2eproto();
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static AuthMessageResponse* default_instance_;
};
// -------------------------------------------------------------------

class SessionInfo : public ::google::protobuf::Message {
 public:
  SessionInfo();
  virtual ~SessionInfo();

  SessionInfo(const SessionInfo& from);

  inline SessionInfo& operator=(const SessionInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SessionInfo& default_instance();

  void Swap(SessionInfo* other);

  // implements Message ----------------------------------------------

  SessionInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SessionInfo& from);
  void MergeFrom(const SessionInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string login = 1;
  inline bool has_login() const;
  inline void clear_login();
  static const int kLoginFieldNumber = 1;
  inline const ::std::string& login() const;
  inline void set_login(const ::std::string& value);
  inline void set_login(const char* value);
  inline void set_login(const char* value, size_t size);
  inline ::std::string* mutable_login();
  inline ::std::string* release_login();
  inline void set_allocated_login(::std::string* login);

  // optional int64 userId = 2;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::int64 userid() const;
  inline void set_userid(::google::protobuf::int64 value);

  // optional int32 role = 3;
  inline bool has_role() const;
  inline void clear_role();
  static const int kRoleFieldNumber = 3;
  inline ::google::protobuf::int32 role() const;
  inline void set_role(::google::protobuf::int32 value);

  // optional string session_id = 4;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 4;
  inline const ::std::string& session_id() const;
  inline void set_session_id(const ::std::string& value);
  inline void set_session_id(const char* value);
  inline void set_session_id(const char* value, size_t size);
  inline ::std::string* mutable_session_id();
  inline ::std::string* release_session_id();
  inline void set_allocated_session_id(::std::string* session_id);

  // @@protoc_insertion_point(class_scope:network.SessionInfo)
 private:
  inline void set_has_login();
  inline void clear_has_login();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_role();
  inline void clear_has_role();
  inline void set_has_session_id();
  inline void clear_has_session_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* login_;
  ::google::protobuf::int64 userid_;
  ::std::string* session_id_;
  ::google::protobuf::int32 role_;
  friend void  protobuf_AddDesc_Message_2eproto();
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static SessionInfo* default_instance_;
};
// -------------------------------------------------------------------

class RoomTypesMessageResponse : public ::google::protobuf::Message {
 public:
  RoomTypesMessageResponse();
  virtual ~RoomTypesMessageResponse();

  RoomTypesMessageResponse(const RoomTypesMessageResponse& from);

  inline RoomTypesMessageResponse& operator=(const RoomTypesMessageResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomTypesMessageResponse& default_instance();

  void Swap(RoomTypesMessageResponse* other);

  // implements Message ----------------------------------------------

  RoomTypesMessageResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoomTypesMessageResponse& from);
  void MergeFrom(const RoomTypesMessageResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string types = 1;
  inline int types_size() const;
  inline void clear_types();
  static const int kTypesFieldNumber = 1;
  inline const ::std::string& types(int index) const;
  inline ::std::string* mutable_types(int index);
  inline void set_types(int index, const ::std::string& value);
  inline void set_types(int index, const char* value);
  inline void set_types(int index, const char* value, size_t size);
  inline ::std::string* add_types();
  inline void add_types(const ::std::string& value);
  inline void add_types(const char* value);
  inline void add_types(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& types() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_types();

  // @@protoc_insertion_point(class_scope:network.RoomTypesMessageResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> types_;
  friend void  protobuf_AddDesc_Message_2eproto();
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static RoomTypesMessageResponse* default_instance_;
};
// -------------------------------------------------------------------

class HotelType : public ::google::protobuf::Message {
 public:
  HotelType();
  virtual ~HotelType();

  HotelType(const HotelType& from);

  inline HotelType& operator=(const HotelType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HotelType& default_instance();

  void Swap(HotelType* other);

  // implements Message ----------------------------------------------

  HotelType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HotelType& from);
  void MergeFrom(const HotelType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:network.HotelType)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::google::protobuf::int32 id_;
  friend void  protobuf_AddDesc_Message_2eproto();
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static HotelType* default_instance_;
};
// -------------------------------------------------------------------

class HotelTypesMessageResponse : public ::google::protobuf::Message {
 public:
  HotelTypesMessageResponse();
  virtual ~HotelTypesMessageResponse();

  HotelTypesMessageResponse(const HotelTypesMessageResponse& from);

  inline HotelTypesMessageResponse& operator=(const HotelTypesMessageResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HotelTypesMessageResponse& default_instance();

  void Swap(HotelTypesMessageResponse* other);

  // implements Message ----------------------------------------------

  HotelTypesMessageResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HotelTypesMessageResponse& from);
  void MergeFrom(const HotelTypesMessageResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .network.HotelType types = 1;
  inline int types_size() const;
  inline void clear_types();
  static const int kTypesFieldNumber = 1;
  inline const ::network::HotelType& types(int index) const;
  inline ::network::HotelType* mutable_types(int index);
  inline ::network::HotelType* add_types();
  inline const ::google::protobuf::RepeatedPtrField< ::network::HotelType >&
      types() const;
  inline ::google::protobuf::RepeatedPtrField< ::network::HotelType >*
      mutable_types();

  // @@protoc_insertion_point(class_scope:network.HotelTypesMessageResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::network::HotelType > types_;
  friend void  protobuf_AddDesc_Message_2eproto();
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static HotelTypesMessageResponse* default_instance_;
};
// -------------------------------------------------------------------

class ResponseContext : public ::google::protobuf::Message {
 public:
  ResponseContext();
  virtual ~ResponseContext();

  ResponseContext(const ResponseContext& from);

  inline ResponseContext& operator=(const ResponseContext& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseContext& default_instance();

  void Swap(ResponseContext* other);

  // implements Message ----------------------------------------------

  ResponseContext* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseContext& from);
  void MergeFrom(const ResponseContext& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 error_code = 1;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 1;
  inline ::google::protobuf::int32 error_code() const;
  inline void set_error_code(::google::protobuf::int32 value);

  // optional .network.message_type message_type_ = 2;
  inline bool has_message_type_() const;
  inline void clear_message_type_();
  static const int kMessageTypeFieldNumber = 2;
  inline ::network::message_type message_type_() const;
  inline void set_message_type_(::network::message_type value);

  // optional .network.RegisterMessageResponse register_response = 3;
  inline bool has_register_response() const;
  inline void clear_register_response();
  static const int kRegisterResponseFieldNumber = 3;
  inline const ::network::RegisterMessageResponse& register_response() const;
  inline ::network::RegisterMessageResponse* mutable_register_response();
  inline ::network::RegisterMessageResponse* release_register_response();
  inline void set_allocated_register_response(::network::RegisterMessageResponse* register_response);

  // optional .network.AuthMessageResponse auth_response = 4;
  inline bool has_auth_response() const;
  inline void clear_auth_response();
  static const int kAuthResponseFieldNumber = 4;
  inline const ::network::AuthMessageResponse& auth_response() const;
  inline ::network::AuthMessageResponse* mutable_auth_response();
  inline ::network::AuthMessageResponse* release_auth_response();
  inline void set_allocated_auth_response(::network::AuthMessageResponse* auth_response);

  // optional .network.SessionInfo session_info = 5;
  inline bool has_session_info() const;
  inline void clear_session_info();
  static const int kSessionInfoFieldNumber = 5;
  inline const ::network::SessionInfo& session_info() const;
  inline ::network::SessionInfo* mutable_session_info();
  inline ::network::SessionInfo* release_session_info();
  inline void set_allocated_session_info(::network::SessionInfo* session_info);

  // optional .network.GuestsMessageResponse guests = 6;
  inline bool has_guests() const;
  inline void clear_guests();
  static const int kGuestsFieldNumber = 6;
  inline const ::network::GuestsMessageResponse& guests() const;
  inline ::network::GuestsMessageResponse* mutable_guests();
  inline ::network::GuestsMessageResponse* release_guests();
  inline void set_allocated_guests(::network::GuestsMessageResponse* guests);

  // optional .network.EmployeesMessageResponse employees = 7;
  inline bool has_employees() const;
  inline void clear_employees();
  static const int kEmployeesFieldNumber = 7;
  inline const ::network::EmployeesMessageResponse& employees() const;
  inline ::network::EmployeesMessageResponse* mutable_employees();
  inline ::network::EmployeesMessageResponse* release_employees();
  inline void set_allocated_employees(::network::EmployeesMessageResponse* employees);

  // optional .network.HotelsMessageResponse hotels = 8;
  inline bool has_hotels() const;
  inline void clear_hotels();
  static const int kHotelsFieldNumber = 8;
  inline const ::network::HotelsMessageResponse& hotels() const;
  inline ::network::HotelsMessageResponse* mutable_hotels();
  inline ::network::HotelsMessageResponse* release_hotels();
  inline void set_allocated_hotels(::network::HotelsMessageResponse* hotels);

  // optional .network.RoomsMessageResponse rooms = 9;
  inline bool has_rooms() const;
  inline void clear_rooms();
  static const int kRoomsFieldNumber = 9;
  inline const ::network::RoomsMessageResponse& rooms() const;
  inline ::network::RoomsMessageResponse* mutable_rooms();
  inline ::network::RoomsMessageResponse* release_rooms();
  inline void set_allocated_rooms(::network::RoomsMessageResponse* rooms);

  // optional .network.RoomTypesMessageResponse types = 10;
  inline bool has_types() const;
  inline void clear_types();
  static const int kTypesFieldNumber = 10;
  inline const ::network::RoomTypesMessageResponse& types() const;
  inline ::network::RoomTypesMessageResponse* mutable_types();
  inline ::network::RoomTypesMessageResponse* release_types();
  inline void set_allocated_types(::network::RoomTypesMessageResponse* types);

  // optional .network.OrdersMessageResponse orders = 11;
  inline bool has_orders() const;
  inline void clear_orders();
  static const int kOrdersFieldNumber = 11;
  inline const ::network::OrdersMessageResponse& orders() const;
  inline ::network::OrdersMessageResponse* mutable_orders();
  inline ::network::OrdersMessageResponse* release_orders();
  inline void set_allocated_orders(::network::OrdersMessageResponse* orders);

  // optional .network.HotelTypesMessageResponse hotel_types = 12;
  inline bool has_hotel_types() const;
  inline void clear_hotel_types();
  static const int kHotelTypesFieldNumber = 12;
  inline const ::network::HotelTypesMessageResponse& hotel_types() const;
  inline ::network::HotelTypesMessageResponse* mutable_hotel_types();
  inline ::network::HotelTypesMessageResponse* release_hotel_types();
  inline void set_allocated_hotel_types(::network::HotelTypesMessageResponse* hotel_types);

  // optional .network.GuestOrdersMessageResponse guest_orders = 13;
  inline bool has_guest_orders() const;
  inline void clear_guest_orders();
  static const int kGuestOrdersFieldNumber = 13;
  inline const ::network::GuestOrdersMessageResponse& guest_orders() const;
  inline ::network::GuestOrdersMessageResponse* mutable_guest_orders();
  inline ::network::GuestOrdersMessageResponse* release_guest_orders();
  inline void set_allocated_guest_orders(::network::GuestOrdersMessageResponse* guest_orders);

  // @@protoc_insertion_point(class_scope:network.ResponseContext)
 private:
  inline void set_has_error_code();
  inline void clear_has_error_code();
  inline void set_has_message_type_();
  inline void clear_has_message_type_();
  inline void set_has_register_response();
  inline void clear_has_register_response();
  inline void set_has_auth_response();
  inline void clear_has_auth_response();
  inline void set_has_session_info();
  inline void clear_has_session_info();
  inline void set_has_guests();
  inline void clear_has_guests();
  inline void set_has_employees();
  inline void clear_has_employees();
  inline void set_has_hotels();
  inline void clear_has_hotels();
  inline void set_has_rooms();
  inline void clear_has_rooms();
  inline void set_has_types();
  inline void clear_has_types();
  inline void set_has_orders();
  inline void clear_has_orders();
  inline void set_has_hotel_types();
  inline void clear_has_hotel_types();
  inline void set_has_guest_orders();
  inline void clear_has_guest_orders();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 error_code_;
  int message_type__;
  ::network::RegisterMessageResponse* register_response_;
  ::network::AuthMessageResponse* auth_response_;
  ::network::SessionInfo* session_info_;
  ::network::GuestsMessageResponse* guests_;
  ::network::EmployeesMessageResponse* employees_;
  ::network::HotelsMessageResponse* hotels_;
  ::network::RoomsMessageResponse* rooms_;
  ::network::RoomTypesMessageResponse* types_;
  ::network::OrdersMessageResponse* orders_;
  ::network::HotelTypesMessageResponse* hotel_types_;
  ::network::GuestOrdersMessageResponse* guest_orders_;
  friend void  protobuf_AddDesc_Message_2eproto();
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static ResponseContext* default_instance_;
};
// ===================================================================


// ===================================================================

// AuthMessage

// optional string login = 1;
inline bool AuthMessage::has_login() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AuthMessage::set_has_login() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AuthMessage::clear_has_login() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AuthMessage::clear_login() {
  if (login_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    login_->clear();
  }
  clear_has_login();
}
inline const ::std::string& AuthMessage::login() const {
  // @@protoc_insertion_point(field_get:network.AuthMessage.login)
  return *login_;
}
inline void AuthMessage::set_login(const ::std::string& value) {
  set_has_login();
  if (login_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    login_ = new ::std::string;
  }
  login_->assign(value);
  // @@protoc_insertion_point(field_set:network.AuthMessage.login)
}
inline void AuthMessage::set_login(const char* value) {
  set_has_login();
  if (login_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    login_ = new ::std::string;
  }
  login_->assign(value);
  // @@protoc_insertion_point(field_set_char:network.AuthMessage.login)
}
inline void AuthMessage::set_login(const char* value, size_t size) {
  set_has_login();
  if (login_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    login_ = new ::std::string;
  }
  login_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:network.AuthMessage.login)
}
inline ::std::string* AuthMessage::mutable_login() {
  set_has_login();
  if (login_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    login_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:network.AuthMessage.login)
  return login_;
}
inline ::std::string* AuthMessage::release_login() {
  clear_has_login();
  if (login_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = login_;
    login_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AuthMessage::set_allocated_login(::std::string* login) {
  if (login_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete login_;
  }
  if (login) {
    set_has_login();
    login_ = login;
  } else {
    clear_has_login();
    login_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:network.AuthMessage.login)
}

// optional string pass = 2;
inline bool AuthMessage::has_pass() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AuthMessage::set_has_pass() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AuthMessage::clear_has_pass() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AuthMessage::clear_pass() {
  if (pass_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pass_->clear();
  }
  clear_has_pass();
}
inline const ::std::string& AuthMessage::pass() const {
  // @@protoc_insertion_point(field_get:network.AuthMessage.pass)
  return *pass_;
}
inline void AuthMessage::set_pass(const ::std::string& value) {
  set_has_pass();
  if (pass_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pass_ = new ::std::string;
  }
  pass_->assign(value);
  // @@protoc_insertion_point(field_set:network.AuthMessage.pass)
}
inline void AuthMessage::set_pass(const char* value) {
  set_has_pass();
  if (pass_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pass_ = new ::std::string;
  }
  pass_->assign(value);
  // @@protoc_insertion_point(field_set_char:network.AuthMessage.pass)
}
inline void AuthMessage::set_pass(const char* value, size_t size) {
  set_has_pass();
  if (pass_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pass_ = new ::std::string;
  }
  pass_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:network.AuthMessage.pass)
}
inline ::std::string* AuthMessage::mutable_pass() {
  set_has_pass();
  if (pass_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pass_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:network.AuthMessage.pass)
  return pass_;
}
inline ::std::string* AuthMessage::release_pass() {
  clear_has_pass();
  if (pass_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = pass_;
    pass_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AuthMessage::set_allocated_pass(::std::string* pass) {
  if (pass_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete pass_;
  }
  if (pass) {
    set_has_pass();
    pass_ = pass;
  } else {
    clear_has_pass();
    pass_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:network.AuthMessage.pass)
}

// -------------------------------------------------------------------

// RegisterMessage

// optional string login = 1;
inline bool RegisterMessage::has_login() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegisterMessage::set_has_login() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegisterMessage::clear_has_login() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegisterMessage::clear_login() {
  if (login_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    login_->clear();
  }
  clear_has_login();
}
inline const ::std::string& RegisterMessage::login() const {
  // @@protoc_insertion_point(field_get:network.RegisterMessage.login)
  return *login_;
}
inline void RegisterMessage::set_login(const ::std::string& value) {
  set_has_login();
  if (login_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    login_ = new ::std::string;
  }
  login_->assign(value);
  // @@protoc_insertion_point(field_set:network.RegisterMessage.login)
}
inline void RegisterMessage::set_login(const char* value) {
  set_has_login();
  if (login_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    login_ = new ::std::string;
  }
  login_->assign(value);
  // @@protoc_insertion_point(field_set_char:network.RegisterMessage.login)
}
inline void RegisterMessage::set_login(const char* value, size_t size) {
  set_has_login();
  if (login_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    login_ = new ::std::string;
  }
  login_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:network.RegisterMessage.login)
}
inline ::std::string* RegisterMessage::mutable_login() {
  set_has_login();
  if (login_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    login_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:network.RegisterMessage.login)
  return login_;
}
inline ::std::string* RegisterMessage::release_login() {
  clear_has_login();
  if (login_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = login_;
    login_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RegisterMessage::set_allocated_login(::std::string* login) {
  if (login_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete login_;
  }
  if (login) {
    set_has_login();
    login_ = login;
  } else {
    clear_has_login();
    login_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:network.RegisterMessage.login)
}

// optional string pass = 2;
inline bool RegisterMessage::has_pass() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegisterMessage::set_has_pass() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegisterMessage::clear_has_pass() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegisterMessage::clear_pass() {
  if (pass_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pass_->clear();
  }
  clear_has_pass();
}
inline const ::std::string& RegisterMessage::pass() const {
  // @@protoc_insertion_point(field_get:network.RegisterMessage.pass)
  return *pass_;
}
inline void RegisterMessage::set_pass(const ::std::string& value) {
  set_has_pass();
  if (pass_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pass_ = new ::std::string;
  }
  pass_->assign(value);
  // @@protoc_insertion_point(field_set:network.RegisterMessage.pass)
}
inline void RegisterMessage::set_pass(const char* value) {
  set_has_pass();
  if (pass_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pass_ = new ::std::string;
  }
  pass_->assign(value);
  // @@protoc_insertion_point(field_set_char:network.RegisterMessage.pass)
}
inline void RegisterMessage::set_pass(const char* value, size_t size) {
  set_has_pass();
  if (pass_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pass_ = new ::std::string;
  }
  pass_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:network.RegisterMessage.pass)
}
inline ::std::string* RegisterMessage::mutable_pass() {
  set_has_pass();
  if (pass_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pass_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:network.RegisterMessage.pass)
  return pass_;
}
inline ::std::string* RegisterMessage::release_pass() {
  clear_has_pass();
  if (pass_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = pass_;
    pass_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RegisterMessage::set_allocated_pass(::std::string* pass) {
  if (pass_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete pass_;
  }
  if (pass) {
    set_has_pass();
    pass_ = pass;
  } else {
    clear_has_pass();
    pass_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:network.RegisterMessage.pass)
}

// optional string firstname = 3;
inline bool RegisterMessage::has_firstname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RegisterMessage::set_has_firstname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RegisterMessage::clear_has_firstname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RegisterMessage::clear_firstname() {
  if (firstname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    firstname_->clear();
  }
  clear_has_firstname();
}
inline const ::std::string& RegisterMessage::firstname() const {
  // @@protoc_insertion_point(field_get:network.RegisterMessage.firstname)
  return *firstname_;
}
inline void RegisterMessage::set_firstname(const ::std::string& value) {
  set_has_firstname();
  if (firstname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    firstname_ = new ::std::string;
  }
  firstname_->assign(value);
  // @@protoc_insertion_point(field_set:network.RegisterMessage.firstname)
}
inline void RegisterMessage::set_firstname(const char* value) {
  set_has_firstname();
  if (firstname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    firstname_ = new ::std::string;
  }
  firstname_->assign(value);
  // @@protoc_insertion_point(field_set_char:network.RegisterMessage.firstname)
}
inline void RegisterMessage::set_firstname(const char* value, size_t size) {
  set_has_firstname();
  if (firstname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    firstname_ = new ::std::string;
  }
  firstname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:network.RegisterMessage.firstname)
}
inline ::std::string* RegisterMessage::mutable_firstname() {
  set_has_firstname();
  if (firstname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    firstname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:network.RegisterMessage.firstname)
  return firstname_;
}
inline ::std::string* RegisterMessage::release_firstname() {
  clear_has_firstname();
  if (firstname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = firstname_;
    firstname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RegisterMessage::set_allocated_firstname(::std::string* firstname) {
  if (firstname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete firstname_;
  }
  if (firstname) {
    set_has_firstname();
    firstname_ = firstname;
  } else {
    clear_has_firstname();
    firstname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:network.RegisterMessage.firstname)
}

// optional string secondname = 4;
inline bool RegisterMessage::has_secondname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RegisterMessage::set_has_secondname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RegisterMessage::clear_has_secondname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RegisterMessage::clear_secondname() {
  if (secondname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    secondname_->clear();
  }
  clear_has_secondname();
}
inline const ::std::string& RegisterMessage::secondname() const {
  // @@protoc_insertion_point(field_get:network.RegisterMessage.secondname)
  return *secondname_;
}
inline void RegisterMessage::set_secondname(const ::std::string& value) {
  set_has_secondname();
  if (secondname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    secondname_ = new ::std::string;
  }
  secondname_->assign(value);
  // @@protoc_insertion_point(field_set:network.RegisterMessage.secondname)
}
inline void RegisterMessage::set_secondname(const char* value) {
  set_has_secondname();
  if (secondname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    secondname_ = new ::std::string;
  }
  secondname_->assign(value);
  // @@protoc_insertion_point(field_set_char:network.RegisterMessage.secondname)
}
inline void RegisterMessage::set_secondname(const char* value, size_t size) {
  set_has_secondname();
  if (secondname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    secondname_ = new ::std::string;
  }
  secondname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:network.RegisterMessage.secondname)
}
inline ::std::string* RegisterMessage::mutable_secondname() {
  set_has_secondname();
  if (secondname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    secondname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:network.RegisterMessage.secondname)
  return secondname_;
}
inline ::std::string* RegisterMessage::release_secondname() {
  clear_has_secondname();
  if (secondname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = secondname_;
    secondname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RegisterMessage::set_allocated_secondname(::std::string* secondname) {
  if (secondname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete secondname_;
  }
  if (secondname) {
    set_has_secondname();
    secondname_ = secondname;
  } else {
    clear_has_secondname();
    secondname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:network.RegisterMessage.secondname)
}

// optional string lastname = 5;
inline bool RegisterMessage::has_lastname() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RegisterMessage::set_has_lastname() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RegisterMessage::clear_has_lastname() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RegisterMessage::clear_lastname() {
  if (lastname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lastname_->clear();
  }
  clear_has_lastname();
}
inline const ::std::string& RegisterMessage::lastname() const {
  // @@protoc_insertion_point(field_get:network.RegisterMessage.lastname)
  return *lastname_;
}
inline void RegisterMessage::set_lastname(const ::std::string& value) {
  set_has_lastname();
  if (lastname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lastname_ = new ::std::string;
  }
  lastname_->assign(value);
  // @@protoc_insertion_point(field_set:network.RegisterMessage.lastname)
}
inline void RegisterMessage::set_lastname(const char* value) {
  set_has_lastname();
  if (lastname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lastname_ = new ::std::string;
  }
  lastname_->assign(value);
  // @@protoc_insertion_point(field_set_char:network.RegisterMessage.lastname)
}
inline void RegisterMessage::set_lastname(const char* value, size_t size) {
  set_has_lastname();
  if (lastname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lastname_ = new ::std::string;
  }
  lastname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:network.RegisterMessage.lastname)
}
inline ::std::string* RegisterMessage::mutable_lastname() {
  set_has_lastname();
  if (lastname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lastname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:network.RegisterMessage.lastname)
  return lastname_;
}
inline ::std::string* RegisterMessage::release_lastname() {
  clear_has_lastname();
  if (lastname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = lastname_;
    lastname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RegisterMessage::set_allocated_lastname(::std::string* lastname) {
  if (lastname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete lastname_;
  }
  if (lastname) {
    set_has_lastname();
    lastname_ = lastname;
  } else {
    clear_has_lastname();
    lastname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:network.RegisterMessage.lastname)
}

// optional string phonenumber = 6;
inline bool RegisterMessage::has_phonenumber() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RegisterMessage::set_has_phonenumber() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RegisterMessage::clear_has_phonenumber() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RegisterMessage::clear_phonenumber() {
  if (phonenumber_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    phonenumber_->clear();
  }
  clear_has_phonenumber();
}
inline const ::std::string& RegisterMessage::phonenumber() const {
  // @@protoc_insertion_point(field_get:network.RegisterMessage.phonenumber)
  return *phonenumber_;
}
inline void RegisterMessage::set_phonenumber(const ::std::string& value) {
  set_has_phonenumber();
  if (phonenumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    phonenumber_ = new ::std::string;
  }
  phonenumber_->assign(value);
  // @@protoc_insertion_point(field_set:network.RegisterMessage.phonenumber)
}
inline void RegisterMessage::set_phonenumber(const char* value) {
  set_has_phonenumber();
  if (phonenumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    phonenumber_ = new ::std::string;
  }
  phonenumber_->assign(value);
  // @@protoc_insertion_point(field_set_char:network.RegisterMessage.phonenumber)
}
inline void RegisterMessage::set_phonenumber(const char* value, size_t size) {
  set_has_phonenumber();
  if (phonenumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    phonenumber_ = new ::std::string;
  }
  phonenumber_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:network.RegisterMessage.phonenumber)
}
inline ::std::string* RegisterMessage::mutable_phonenumber() {
  set_has_phonenumber();
  if (phonenumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    phonenumber_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:network.RegisterMessage.phonenumber)
  return phonenumber_;
}
inline ::std::string* RegisterMessage::release_phonenumber() {
  clear_has_phonenumber();
  if (phonenumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = phonenumber_;
    phonenumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RegisterMessage::set_allocated_phonenumber(::std::string* phonenumber) {
  if (phonenumber_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete phonenumber_;
  }
  if (phonenumber) {
    set_has_phonenumber();
    phonenumber_ = phonenumber;
  } else {
    clear_has_phonenumber();
    phonenumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:network.RegisterMessage.phonenumber)
}

// optional string passport = 7;
inline bool RegisterMessage::has_passport() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RegisterMessage::set_has_passport() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RegisterMessage::clear_has_passport() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RegisterMessage::clear_passport() {
  if (passport_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    passport_->clear();
  }
  clear_has_passport();
}
inline const ::std::string& RegisterMessage::passport() const {
  // @@protoc_insertion_point(field_get:network.RegisterMessage.passport)
  return *passport_;
}
inline void RegisterMessage::set_passport(const ::std::string& value) {
  set_has_passport();
  if (passport_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    passport_ = new ::std::string;
  }
  passport_->assign(value);
  // @@protoc_insertion_point(field_set:network.RegisterMessage.passport)
}
inline void RegisterMessage::set_passport(const char* value) {
  set_has_passport();
  if (passport_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    passport_ = new ::std::string;
  }
  passport_->assign(value);
  // @@protoc_insertion_point(field_set_char:network.RegisterMessage.passport)
}
inline void RegisterMessage::set_passport(const char* value, size_t size) {
  set_has_passport();
  if (passport_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    passport_ = new ::std::string;
  }
  passport_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:network.RegisterMessage.passport)
}
inline ::std::string* RegisterMessage::mutable_passport() {
  set_has_passport();
  if (passport_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    passport_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:network.RegisterMessage.passport)
  return passport_;
}
inline ::std::string* RegisterMessage::release_passport() {
  clear_has_passport();
  if (passport_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = passport_;
    passport_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RegisterMessage::set_allocated_passport(::std::string* passport) {
  if (passport_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete passport_;
  }
  if (passport) {
    set_has_passport();
    passport_ = passport;
  } else {
    clear_has_passport();
    passport_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:network.RegisterMessage.passport)
}

// optional int32 role = 8;
inline bool RegisterMessage::has_role() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RegisterMessage::set_has_role() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RegisterMessage::clear_has_role() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RegisterMessage::clear_role() {
  role_ = 0;
  clear_has_role();
}
inline ::google::protobuf::int32 RegisterMessage::role() const {
  // @@protoc_insertion_point(field_get:network.RegisterMessage.role)
  return role_;
}
inline void RegisterMessage::set_role(::google::protobuf::int32 value) {
  set_has_role();
  role_ = value;
  // @@protoc_insertion_point(field_set:network.RegisterMessage.role)
}

// -------------------------------------------------------------------

// RegisterEmployeeMessage

// optional string login = 1;
inline bool RegisterEmployeeMessage::has_login() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegisterEmployeeMessage::set_has_login() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegisterEmployeeMessage::clear_has_login() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegisterEmployeeMessage::clear_login() {
  if (login_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    login_->clear();
  }
  clear_has_login();
}
inline const ::std::string& RegisterEmployeeMessage::login() const {
  // @@protoc_insertion_point(field_get:network.RegisterEmployeeMessage.login)
  return *login_;
}
inline void RegisterEmployeeMessage::set_login(const ::std::string& value) {
  set_has_login();
  if (login_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    login_ = new ::std::string;
  }
  login_->assign(value);
  // @@protoc_insertion_point(field_set:network.RegisterEmployeeMessage.login)
}
inline void RegisterEmployeeMessage::set_login(const char* value) {
  set_has_login();
  if (login_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    login_ = new ::std::string;
  }
  login_->assign(value);
  // @@protoc_insertion_point(field_set_char:network.RegisterEmployeeMessage.login)
}
inline void RegisterEmployeeMessage::set_login(const char* value, size_t size) {
  set_has_login();
  if (login_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    login_ = new ::std::string;
  }
  login_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:network.RegisterEmployeeMessage.login)
}
inline ::std::string* RegisterEmployeeMessage::mutable_login() {
  set_has_login();
  if (login_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    login_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:network.RegisterEmployeeMessage.login)
  return login_;
}
inline ::std::string* RegisterEmployeeMessage::release_login() {
  clear_has_login();
  if (login_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = login_;
    login_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RegisterEmployeeMessage::set_allocated_login(::std::string* login) {
  if (login_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete login_;
  }
  if (login) {
    set_has_login();
    login_ = login;
  } else {
    clear_has_login();
    login_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:network.RegisterEmployeeMessage.login)
}

// optional string pass = 2;
inline bool RegisterEmployeeMessage::has_pass() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegisterEmployeeMessage::set_has_pass() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegisterEmployeeMessage::clear_has_pass() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegisterEmployeeMessage::clear_pass() {
  if (pass_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pass_->clear();
  }
  clear_has_pass();
}
inline const ::std::string& RegisterEmployeeMessage::pass() const {
  // @@protoc_insertion_point(field_get:network.RegisterEmployeeMessage.pass)
  return *pass_;
}
inline void RegisterEmployeeMessage::set_pass(const ::std::string& value) {
  set_has_pass();
  if (pass_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pass_ = new ::std::string;
  }
  pass_->assign(value);
  // @@protoc_insertion_point(field_set:network.RegisterEmployeeMessage.pass)
}
inline void RegisterEmployeeMessage::set_pass(const char* value) {
  set_has_pass();
  if (pass_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pass_ = new ::std::string;
  }
  pass_->assign(value);
  // @@protoc_insertion_point(field_set_char:network.RegisterEmployeeMessage.pass)
}
inline void RegisterEmployeeMessage::set_pass(const char* value, size_t size) {
  set_has_pass();
  if (pass_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pass_ = new ::std::string;
  }
  pass_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:network.RegisterEmployeeMessage.pass)
}
inline ::std::string* RegisterEmployeeMessage::mutable_pass() {
  set_has_pass();
  if (pass_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pass_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:network.RegisterEmployeeMessage.pass)
  return pass_;
}
inline ::std::string* RegisterEmployeeMessage::release_pass() {
  clear_has_pass();
  if (pass_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = pass_;
    pass_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RegisterEmployeeMessage::set_allocated_pass(::std::string* pass) {
  if (pass_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete pass_;
  }
  if (pass) {
    set_has_pass();
    pass_ = pass;
  } else {
    clear_has_pass();
    pass_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:network.RegisterEmployeeMessage.pass)
}

// optional string firstname = 3;
inline bool RegisterEmployeeMessage::has_firstname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RegisterEmployeeMessage::set_has_firstname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RegisterEmployeeMessage::clear_has_firstname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RegisterEmployeeMessage::clear_firstname() {
  if (firstname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    firstname_->clear();
  }
  clear_has_firstname();
}
inline const ::std::string& RegisterEmployeeMessage::firstname() const {
  // @@protoc_insertion_point(field_get:network.RegisterEmployeeMessage.firstname)
  return *firstname_;
}
inline void RegisterEmployeeMessage::set_firstname(const ::std::string& value) {
  set_has_firstname();
  if (firstname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    firstname_ = new ::std::string;
  }
  firstname_->assign(value);
  // @@protoc_insertion_point(field_set:network.RegisterEmployeeMessage.firstname)
}
inline void RegisterEmployeeMessage::set_firstname(const char* value) {
  set_has_firstname();
  if (firstname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    firstname_ = new ::std::string;
  }
  firstname_->assign(value);
  // @@protoc_insertion_point(field_set_char:network.RegisterEmployeeMessage.firstname)
}
inline void RegisterEmployeeMessage::set_firstname(const char* value, size_t size) {
  set_has_firstname();
  if (firstname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    firstname_ = new ::std::string;
  }
  firstname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:network.RegisterEmployeeMessage.firstname)
}
inline ::std::string* RegisterEmployeeMessage::mutable_firstname() {
  set_has_firstname();
  if (firstname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    firstname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:network.RegisterEmployeeMessage.firstname)
  return firstname_;
}
inline ::std::string* RegisterEmployeeMessage::release_firstname() {
  clear_has_firstname();
  if (firstname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = firstname_;
    firstname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RegisterEmployeeMessage::set_allocated_firstname(::std::string* firstname) {
  if (firstname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete firstname_;
  }
  if (firstname) {
    set_has_firstname();
    firstname_ = firstname;
  } else {
    clear_has_firstname();
    firstname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:network.RegisterEmployeeMessage.firstname)
}

// optional string secondname = 4;
inline bool RegisterEmployeeMessage::has_secondname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RegisterEmployeeMessage::set_has_secondname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RegisterEmployeeMessage::clear_has_secondname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RegisterEmployeeMessage::clear_secondname() {
  if (secondname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    secondname_->clear();
  }
  clear_has_secondname();
}
inline const ::std::string& RegisterEmployeeMessage::secondname() const {
  // @@protoc_insertion_point(field_get:network.RegisterEmployeeMessage.secondname)
  return *secondname_;
}
inline void RegisterEmployeeMessage::set_secondname(const ::std::string& value) {
  set_has_secondname();
  if (secondname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    secondname_ = new ::std::string;
  }
  secondname_->assign(value);
  // @@protoc_insertion_point(field_set:network.RegisterEmployeeMessage.secondname)
}
inline void RegisterEmployeeMessage::set_secondname(const char* value) {
  set_has_secondname();
  if (secondname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    secondname_ = new ::std::string;
  }
  secondname_->assign(value);
  // @@protoc_insertion_point(field_set_char:network.RegisterEmployeeMessage.secondname)
}
inline void RegisterEmployeeMessage::set_secondname(const char* value, size_t size) {
  set_has_secondname();
  if (secondname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    secondname_ = new ::std::string;
  }
  secondname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:network.RegisterEmployeeMessage.secondname)
}
inline ::std::string* RegisterEmployeeMessage::mutable_secondname() {
  set_has_secondname();
  if (secondname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    secondname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:network.RegisterEmployeeMessage.secondname)
  return secondname_;
}
inline ::std::string* RegisterEmployeeMessage::release_secondname() {
  clear_has_secondname();
  if (secondname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = secondname_;
    secondname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RegisterEmployeeMessage::set_allocated_secondname(::std::string* secondname) {
  if (secondname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete secondname_;
  }
  if (secondname) {
    set_has_secondname();
    secondname_ = secondname;
  } else {
    clear_has_secondname();
    secondname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:network.RegisterEmployeeMessage.secondname)
}

// optional string lastname = 5;
inline bool RegisterEmployeeMessage::has_lastname() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RegisterEmployeeMessage::set_has_lastname() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RegisterEmployeeMessage::clear_has_lastname() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RegisterEmployeeMessage::clear_lastname() {
  if (lastname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lastname_->clear();
  }
  clear_has_lastname();
}
inline const ::std::string& RegisterEmployeeMessage::lastname() const {
  // @@protoc_insertion_point(field_get:network.RegisterEmployeeMessage.lastname)
  return *lastname_;
}
inline void RegisterEmployeeMessage::set_lastname(const ::std::string& value) {
  set_has_lastname();
  if (lastname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lastname_ = new ::std::string;
  }
  lastname_->assign(value);
  // @@protoc_insertion_point(field_set:network.RegisterEmployeeMessage.lastname)
}
inline void RegisterEmployeeMessage::set_lastname(const char* value) {
  set_has_lastname();
  if (lastname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lastname_ = new ::std::string;
  }
  lastname_->assign(value);
  // @@protoc_insertion_point(field_set_char:network.RegisterEmployeeMessage.lastname)
}
inline void RegisterEmployeeMessage::set_lastname(const char* value, size_t size) {
  set_has_lastname();
  if (lastname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lastname_ = new ::std::string;
  }
  lastname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:network.RegisterEmployeeMessage.lastname)
}
inline ::std::string* RegisterEmployeeMessage::mutable_lastname() {
  set_has_lastname();
  if (lastname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lastname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:network.RegisterEmployeeMessage.lastname)
  return lastname_;
}
inline ::std::string* RegisterEmployeeMessage::release_lastname() {
  clear_has_lastname();
  if (lastname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = lastname_;
    lastname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RegisterEmployeeMessage::set_allocated_lastname(::std::string* lastname) {
  if (lastname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete lastname_;
  }
  if (lastname) {
    set_has_lastname();
    lastname_ = lastname;
  } else {
    clear_has_lastname();
    lastname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:network.RegisterEmployeeMessage.lastname)
}

// optional string phonenumber = 6;
inline bool RegisterEmployeeMessage::has_phonenumber() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RegisterEmployeeMessage::set_has_phonenumber() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RegisterEmployeeMessage::clear_has_phonenumber() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RegisterEmployeeMessage::clear_phonenumber() {
  if (phonenumber_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    phonenumber_->clear();
  }
  clear_has_phonenumber();
}
inline const ::std::string& RegisterEmployeeMessage::phonenumber() const {
  // @@protoc_insertion_point(field_get:network.RegisterEmployeeMessage.phonenumber)
  return *phonenumber_;
}
inline void RegisterEmployeeMessage::set_phonenumber(const ::std::string& value) {
  set_has_phonenumber();
  if (phonenumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    phonenumber_ = new ::std::string;
  }
  phonenumber_->assign(value);
  // @@protoc_insertion_point(field_set:network.RegisterEmployeeMessage.phonenumber)
}
inline void RegisterEmployeeMessage::set_phonenumber(const char* value) {
  set_has_phonenumber();
  if (phonenumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    phonenumber_ = new ::std::string;
  }
  phonenumber_->assign(value);
  // @@protoc_insertion_point(field_set_char:network.RegisterEmployeeMessage.phonenumber)
}
inline void RegisterEmployeeMessage::set_phonenumber(const char* value, size_t size) {
  set_has_phonenumber();
  if (phonenumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    phonenumber_ = new ::std::string;
  }
  phonenumber_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:network.RegisterEmployeeMessage.phonenumber)
}
inline ::std::string* RegisterEmployeeMessage::mutable_phonenumber() {
  set_has_phonenumber();
  if (phonenumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    phonenumber_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:network.RegisterEmployeeMessage.phonenumber)
  return phonenumber_;
}
inline ::std::string* RegisterEmployeeMessage::release_phonenumber() {
  clear_has_phonenumber();
  if (phonenumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = phonenumber_;
    phonenumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RegisterEmployeeMessage::set_allocated_phonenumber(::std::string* phonenumber) {
  if (phonenumber_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete phonenumber_;
  }
  if (phonenumber) {
    set_has_phonenumber();
    phonenumber_ = phonenumber;
  } else {
    clear_has_phonenumber();
    phonenumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:network.RegisterEmployeeMessage.phonenumber)
}

// optional int32 salary = 7;
inline bool RegisterEmployeeMessage::has_salary() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RegisterEmployeeMessage::set_has_salary() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RegisterEmployeeMessage::clear_has_salary() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RegisterEmployeeMessage::clear_salary() {
  salary_ = 0;
  clear_has_salary();
}
inline ::google::protobuf::int32 RegisterEmployeeMessage::salary() const {
  // @@protoc_insertion_point(field_get:network.RegisterEmployeeMessage.salary)
  return salary_;
}
inline void RegisterEmployeeMessage::set_salary(::google::protobuf::int32 value) {
  set_has_salary();
  salary_ = value;
  // @@protoc_insertion_point(field_set:network.RegisterEmployeeMessage.salary)
}

// optional int32 position = 8;
inline bool RegisterEmployeeMessage::has_position() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RegisterEmployeeMessage::set_has_position() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RegisterEmployeeMessage::clear_has_position() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RegisterEmployeeMessage::clear_position() {
  position_ = 0;
  clear_has_position();
}
inline ::google::protobuf::int32 RegisterEmployeeMessage::position() const {
  // @@protoc_insertion_point(field_get:network.RegisterEmployeeMessage.position)
  return position_;
}
inline void RegisterEmployeeMessage::set_position(::google::protobuf::int32 value) {
  set_has_position();
  position_ = value;
  // @@protoc_insertion_point(field_set:network.RegisterEmployeeMessage.position)
}

// optional int32 hotelId = 9;
inline bool RegisterEmployeeMessage::has_hotelid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RegisterEmployeeMessage::set_has_hotelid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RegisterEmployeeMessage::clear_has_hotelid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RegisterEmployeeMessage::clear_hotelid() {
  hotelid_ = 0;
  clear_has_hotelid();
}
inline ::google::protobuf::int32 RegisterEmployeeMessage::hotelid() const {
  // @@protoc_insertion_point(field_get:network.RegisterEmployeeMessage.hotelId)
  return hotelid_;
}
inline void RegisterEmployeeMessage::set_hotelid(::google::protobuf::int32 value) {
  set_has_hotelid();
  hotelid_ = value;
  // @@protoc_insertion_point(field_set:network.RegisterEmployeeMessage.hotelId)
}

// optional int32 role = 10;
inline bool RegisterEmployeeMessage::has_role() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RegisterEmployeeMessage::set_has_role() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RegisterEmployeeMessage::clear_has_role() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RegisterEmployeeMessage::clear_role() {
  role_ = 0;
  clear_has_role();
}
inline ::google::protobuf::int32 RegisterEmployeeMessage::role() const {
  // @@protoc_insertion_point(field_get:network.RegisterEmployeeMessage.role)
  return role_;
}
inline void RegisterEmployeeMessage::set_role(::google::protobuf::int32 value) {
  set_has_role();
  role_ = value;
  // @@protoc_insertion_point(field_set:network.RegisterEmployeeMessage.role)
}

// -------------------------------------------------------------------

// GuestInfo

// optional string firstname = 1;
inline bool GuestInfo::has_firstname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GuestInfo::set_has_firstname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GuestInfo::clear_has_firstname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GuestInfo::clear_firstname() {
  if (firstname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    firstname_->clear();
  }
  clear_has_firstname();
}
inline const ::std::string& GuestInfo::firstname() const {
  // @@protoc_insertion_point(field_get:network.GuestInfo.firstname)
  return *firstname_;
}
inline void GuestInfo::set_firstname(const ::std::string& value) {
  set_has_firstname();
  if (firstname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    firstname_ = new ::std::string;
  }
  firstname_->assign(value);
  // @@protoc_insertion_point(field_set:network.GuestInfo.firstname)
}
inline void GuestInfo::set_firstname(const char* value) {
  set_has_firstname();
  if (firstname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    firstname_ = new ::std::string;
  }
  firstname_->assign(value);
  // @@protoc_insertion_point(field_set_char:network.GuestInfo.firstname)
}
inline void GuestInfo::set_firstname(const char* value, size_t size) {
  set_has_firstname();
  if (firstname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    firstname_ = new ::std::string;
  }
  firstname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:network.GuestInfo.firstname)
}
inline ::std::string* GuestInfo::mutable_firstname() {
  set_has_firstname();
  if (firstname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    firstname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:network.GuestInfo.firstname)
  return firstname_;
}
inline ::std::string* GuestInfo::release_firstname() {
  clear_has_firstname();
  if (firstname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = firstname_;
    firstname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GuestInfo::set_allocated_firstname(::std::string* firstname) {
  if (firstname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete firstname_;
  }
  if (firstname) {
    set_has_firstname();
    firstname_ = firstname;
  } else {
    clear_has_firstname();
    firstname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:network.GuestInfo.firstname)
}

// optional string secondname = 2;
inline bool GuestInfo::has_secondname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GuestInfo::set_has_secondname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GuestInfo::clear_has_secondname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GuestInfo::clear_secondname() {
  if (secondname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    secondname_->clear();
  }
  clear_has_secondname();
}
inline const ::std::string& GuestInfo::secondname() const {
  // @@protoc_insertion_point(field_get:network.GuestInfo.secondname)
  return *secondname_;
}
inline void GuestInfo::set_secondname(const ::std::string& value) {
  set_has_secondname();
  if (secondname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    secondname_ = new ::std::string;
  }
  secondname_->assign(value);
  // @@protoc_insertion_point(field_set:network.GuestInfo.secondname)
}
inline void GuestInfo::set_secondname(const char* value) {
  set_has_secondname();
  if (secondname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    secondname_ = new ::std::string;
  }
  secondname_->assign(value);
  // @@protoc_insertion_point(field_set_char:network.GuestInfo.secondname)
}
inline void GuestInfo::set_secondname(const char* value, size_t size) {
  set_has_secondname();
  if (secondname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    secondname_ = new ::std::string;
  }
  secondname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:network.GuestInfo.secondname)
}
inline ::std::string* GuestInfo::mutable_secondname() {
  set_has_secondname();
  if (secondname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    secondname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:network.GuestInfo.secondname)
  return secondname_;
}
inline ::std::string* GuestInfo::release_secondname() {
  clear_has_secondname();
  if (secondname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = secondname_;
    secondname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GuestInfo::set_allocated_secondname(::std::string* secondname) {
  if (secondname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete secondname_;
  }
  if (secondname) {
    set_has_secondname();
    secondname_ = secondname;
  } else {
    clear_has_secondname();
    secondname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:network.GuestInfo.secondname)
}

// optional string lastname = 3;
inline bool GuestInfo::has_lastname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GuestInfo::set_has_lastname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GuestInfo::clear_has_lastname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GuestInfo::clear_lastname() {
  if (lastname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lastname_->clear();
  }
  clear_has_lastname();
}
inline const ::std::string& GuestInfo::lastname() const {
  // @@protoc_insertion_point(field_get:network.GuestInfo.lastname)
  return *lastname_;
}
inline void GuestInfo::set_lastname(const ::std::string& value) {
  set_has_lastname();
  if (lastname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lastname_ = new ::std::string;
  }
  lastname_->assign(value);
  // @@protoc_insertion_point(field_set:network.GuestInfo.lastname)
}
inline void GuestInfo::set_lastname(const char* value) {
  set_has_lastname();
  if (lastname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lastname_ = new ::std::string;
  }
  lastname_->assign(value);
  // @@protoc_insertion_point(field_set_char:network.GuestInfo.lastname)
}
inline void GuestInfo::set_lastname(const char* value, size_t size) {
  set_has_lastname();
  if (lastname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lastname_ = new ::std::string;
  }
  lastname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:network.GuestInfo.lastname)
}
inline ::std::string* GuestInfo::mutable_lastname() {
  set_has_lastname();
  if (lastname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lastname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:network.GuestInfo.lastname)
  return lastname_;
}
inline ::std::string* GuestInfo::release_lastname() {
  clear_has_lastname();
  if (lastname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = lastname_;
    lastname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GuestInfo::set_allocated_lastname(::std::string* lastname) {
  if (lastname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete lastname_;
  }
  if (lastname) {
    set_has_lastname();
    lastname_ = lastname;
  } else {
    clear_has_lastname();
    lastname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:network.GuestInfo.lastname)
}

// optional string phonenumber = 4;
inline bool GuestInfo::has_phonenumber() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GuestInfo::set_has_phonenumber() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GuestInfo::clear_has_phonenumber() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GuestInfo::clear_phonenumber() {
  if (phonenumber_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    phonenumber_->clear();
  }
  clear_has_phonenumber();
}
inline const ::std::string& GuestInfo::phonenumber() const {
  // @@protoc_insertion_point(field_get:network.GuestInfo.phonenumber)
  return *phonenumber_;
}
inline void GuestInfo::set_phonenumber(const ::std::string& value) {
  set_has_phonenumber();
  if (phonenumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    phonenumber_ = new ::std::string;
  }
  phonenumber_->assign(value);
  // @@protoc_insertion_point(field_set:network.GuestInfo.phonenumber)
}
inline void GuestInfo::set_phonenumber(const char* value) {
  set_has_phonenumber();
  if (phonenumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    phonenumber_ = new ::std::string;
  }
  phonenumber_->assign(value);
  // @@protoc_insertion_point(field_set_char:network.GuestInfo.phonenumber)
}
inline void GuestInfo::set_phonenumber(const char* value, size_t size) {
  set_has_phonenumber();
  if (phonenumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    phonenumber_ = new ::std::string;
  }
  phonenumber_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:network.GuestInfo.phonenumber)
}
inline ::std::string* GuestInfo::mutable_phonenumber() {
  set_has_phonenumber();
  if (phonenumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    phonenumber_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:network.GuestInfo.phonenumber)
  return phonenumber_;
}
inline ::std::string* GuestInfo::release_phonenumber() {
  clear_has_phonenumber();
  if (phonenumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = phonenumber_;
    phonenumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GuestInfo::set_allocated_phonenumber(::std::string* phonenumber) {
  if (phonenumber_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete phonenumber_;
  }
  if (phonenumber) {
    set_has_phonenumber();
    phonenumber_ = phonenumber;
  } else {
    clear_has_phonenumber();
    phonenumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:network.GuestInfo.phonenumber)
}

// optional string passport = 5;
inline bool GuestInfo::has_passport() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GuestInfo::set_has_passport() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GuestInfo::clear_has_passport() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GuestInfo::clear_passport() {
  if (passport_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    passport_->clear();
  }
  clear_has_passport();
}
inline const ::std::string& GuestInfo::passport() const {
  // @@protoc_insertion_point(field_get:network.GuestInfo.passport)
  return *passport_;
}
inline void GuestInfo::set_passport(const ::std::string& value) {
  set_has_passport();
  if (passport_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    passport_ = new ::std::string;
  }
  passport_->assign(value);
  // @@protoc_insertion_point(field_set:network.GuestInfo.passport)
}
inline void GuestInfo::set_passport(const char* value) {
  set_has_passport();
  if (passport_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    passport_ = new ::std::string;
  }
  passport_->assign(value);
  // @@protoc_insertion_point(field_set_char:network.GuestInfo.passport)
}
inline void GuestInfo::set_passport(const char* value, size_t size) {
  set_has_passport();
  if (passport_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    passport_ = new ::std::string;
  }
  passport_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:network.GuestInfo.passport)
}
inline ::std::string* GuestInfo::mutable_passport() {
  set_has_passport();
  if (passport_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    passport_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:network.GuestInfo.passport)
  return passport_;
}
inline ::std::string* GuestInfo::release_passport() {
  clear_has_passport();
  if (passport_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = passport_;
    passport_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GuestInfo::set_allocated_passport(::std::string* passport) {
  if (passport_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete passport_;
  }
  if (passport) {
    set_has_passport();
    passport_ = passport;
  } else {
    clear_has_passport();
    passport_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:network.GuestInfo.passport)
}

// optional int32 id = 6;
inline bool GuestInfo::has_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GuestInfo::set_has_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GuestInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GuestInfo::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 GuestInfo::id() const {
  // @@protoc_insertion_point(field_get:network.GuestInfo.id)
  return id_;
}
inline void GuestInfo::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:network.GuestInfo.id)
}

// -------------------------------------------------------------------

// GuestsMessageResponse

// repeated .network.GuestInfo guests = 1;
inline int GuestsMessageResponse::guests_size() const {
  return guests_.size();
}
inline void GuestsMessageResponse::clear_guests() {
  guests_.Clear();
}
inline const ::network::GuestInfo& GuestsMessageResponse::guests(int index) const {
  // @@protoc_insertion_point(field_get:network.GuestsMessageResponse.guests)
  return guests_.Get(index);
}
inline ::network::GuestInfo* GuestsMessageResponse::mutable_guests(int index) {
  // @@protoc_insertion_point(field_mutable:network.GuestsMessageResponse.guests)
  return guests_.Mutable(index);
}
inline ::network::GuestInfo* GuestsMessageResponse::add_guests() {
  // @@protoc_insertion_point(field_add:network.GuestsMessageResponse.guests)
  return guests_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::network::GuestInfo >&
GuestsMessageResponse::guests() const {
  // @@protoc_insertion_point(field_list:network.GuestsMessageResponse.guests)
  return guests_;
}
inline ::google::protobuf::RepeatedPtrField< ::network::GuestInfo >*
GuestsMessageResponse::mutable_guests() {
  // @@protoc_insertion_point(field_mutable_list:network.GuestsMessageResponse.guests)
  return &guests_;
}

// -------------------------------------------------------------------

// EmployeeInfo

// optional string firstname = 1;
inline bool EmployeeInfo::has_firstname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EmployeeInfo::set_has_firstname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EmployeeInfo::clear_has_firstname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EmployeeInfo::clear_firstname() {
  if (firstname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    firstname_->clear();
  }
  clear_has_firstname();
}
inline const ::std::string& EmployeeInfo::firstname() const {
  // @@protoc_insertion_point(field_get:network.EmployeeInfo.firstname)
  return *firstname_;
}
inline void EmployeeInfo::set_firstname(const ::std::string& value) {
  set_has_firstname();
  if (firstname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    firstname_ = new ::std::string;
  }
  firstname_->assign(value);
  // @@protoc_insertion_point(field_set:network.EmployeeInfo.firstname)
}
inline void EmployeeInfo::set_firstname(const char* value) {
  set_has_firstname();
  if (firstname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    firstname_ = new ::std::string;
  }
  firstname_->assign(value);
  // @@protoc_insertion_point(field_set_char:network.EmployeeInfo.firstname)
}
inline void EmployeeInfo::set_firstname(const char* value, size_t size) {
  set_has_firstname();
  if (firstname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    firstname_ = new ::std::string;
  }
  firstname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:network.EmployeeInfo.firstname)
}
inline ::std::string* EmployeeInfo::mutable_firstname() {
  set_has_firstname();
  if (firstname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    firstname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:network.EmployeeInfo.firstname)
  return firstname_;
}
inline ::std::string* EmployeeInfo::release_firstname() {
  clear_has_firstname();
  if (firstname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = firstname_;
    firstname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void EmployeeInfo::set_allocated_firstname(::std::string* firstname) {
  if (firstname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete firstname_;
  }
  if (firstname) {
    set_has_firstname();
    firstname_ = firstname;
  } else {
    clear_has_firstname();
    firstname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:network.EmployeeInfo.firstname)
}

// optional string secondname = 2;
inline bool EmployeeInfo::has_secondname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EmployeeInfo::set_has_secondname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EmployeeInfo::clear_has_secondname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EmployeeInfo::clear_secondname() {
  if (secondname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    secondname_->clear();
  }
  clear_has_secondname();
}
inline const ::std::string& EmployeeInfo::secondname() const {
  // @@protoc_insertion_point(field_get:network.EmployeeInfo.secondname)
  return *secondname_;
}
inline void EmployeeInfo::set_secondname(const ::std::string& value) {
  set_has_secondname();
  if (secondname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    secondname_ = new ::std::string;
  }
  secondname_->assign(value);
  // @@protoc_insertion_point(field_set:network.EmployeeInfo.secondname)
}
inline void EmployeeInfo::set_secondname(const char* value) {
  set_has_secondname();
  if (secondname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    secondname_ = new ::std::string;
  }
  secondname_->assign(value);
  // @@protoc_insertion_point(field_set_char:network.EmployeeInfo.secondname)
}
inline void EmployeeInfo::set_secondname(const char* value, size_t size) {
  set_has_secondname();
  if (secondname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    secondname_ = new ::std::string;
  }
  secondname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:network.EmployeeInfo.secondname)
}
inline ::std::string* EmployeeInfo::mutable_secondname() {
  set_has_secondname();
  if (secondname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    secondname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:network.EmployeeInfo.secondname)
  return secondname_;
}
inline ::std::string* EmployeeInfo::release_secondname() {
  clear_has_secondname();
  if (secondname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = secondname_;
    secondname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void EmployeeInfo::set_allocated_secondname(::std::string* secondname) {
  if (secondname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete secondname_;
  }
  if (secondname) {
    set_has_secondname();
    secondname_ = secondname;
  } else {
    clear_has_secondname();
    secondname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:network.EmployeeInfo.secondname)
}

// optional string lastname = 3;
inline bool EmployeeInfo::has_lastname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EmployeeInfo::set_has_lastname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EmployeeInfo::clear_has_lastname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EmployeeInfo::clear_lastname() {
  if (lastname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lastname_->clear();
  }
  clear_has_lastname();
}
inline const ::std::string& EmployeeInfo::lastname() const {
  // @@protoc_insertion_point(field_get:network.EmployeeInfo.lastname)
  return *lastname_;
}
inline void EmployeeInfo::set_lastname(const ::std::string& value) {
  set_has_lastname();
  if (lastname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lastname_ = new ::std::string;
  }
  lastname_->assign(value);
  // @@protoc_insertion_point(field_set:network.EmployeeInfo.lastname)
}
inline void EmployeeInfo::set_lastname(const char* value) {
  set_has_lastname();
  if (lastname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lastname_ = new ::std::string;
  }
  lastname_->assign(value);
  // @@protoc_insertion_point(field_set_char:network.EmployeeInfo.lastname)
}
inline void EmployeeInfo::set_lastname(const char* value, size_t size) {
  set_has_lastname();
  if (lastname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lastname_ = new ::std::string;
  }
  lastname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:network.EmployeeInfo.lastname)
}
inline ::std::string* EmployeeInfo::mutable_lastname() {
  set_has_lastname();
  if (lastname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lastname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:network.EmployeeInfo.lastname)
  return lastname_;
}
inline ::std::string* EmployeeInfo::release_lastname() {
  clear_has_lastname();
  if (lastname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = lastname_;
    lastname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void EmployeeInfo::set_allocated_lastname(::std::string* lastname) {
  if (lastname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete lastname_;
  }
  if (lastname) {
    set_has_lastname();
    lastname_ = lastname;
  } else {
    clear_has_lastname();
    lastname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:network.EmployeeInfo.lastname)
}

// optional string phonenumber = 4;
inline bool EmployeeInfo::has_phonenumber() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EmployeeInfo::set_has_phonenumber() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EmployeeInfo::clear_has_phonenumber() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EmployeeInfo::clear_phonenumber() {
  if (phonenumber_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    phonenumber_->clear();
  }
  clear_has_phonenumber();
}
inline const ::std::string& EmployeeInfo::phonenumber() const {
  // @@protoc_insertion_point(field_get:network.EmployeeInfo.phonenumber)
  return *phonenumber_;
}
inline void EmployeeInfo::set_phonenumber(const ::std::string& value) {
  set_has_phonenumber();
  if (phonenumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    phonenumber_ = new ::std::string;
  }
  phonenumber_->assign(value);
  // @@protoc_insertion_point(field_set:network.EmployeeInfo.phonenumber)
}
inline void EmployeeInfo::set_phonenumber(const char* value) {
  set_has_phonenumber();
  if (phonenumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    phonenumber_ = new ::std::string;
  }
  phonenumber_->assign(value);
  // @@protoc_insertion_point(field_set_char:network.EmployeeInfo.phonenumber)
}
inline void EmployeeInfo::set_phonenumber(const char* value, size_t size) {
  set_has_phonenumber();
  if (phonenumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    phonenumber_ = new ::std::string;
  }
  phonenumber_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:network.EmployeeInfo.phonenumber)
}
inline ::std::string* EmployeeInfo::mutable_phonenumber() {
  set_has_phonenumber();
  if (phonenumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    phonenumber_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:network.EmployeeInfo.phonenumber)
  return phonenumber_;
}
inline ::std::string* EmployeeInfo::release_phonenumber() {
  clear_has_phonenumber();
  if (phonenumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = phonenumber_;
    phonenumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void EmployeeInfo::set_allocated_phonenumber(::std::string* phonenumber) {
  if (phonenumber_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete phonenumber_;
  }
  if (phonenumber) {
    set_has_phonenumber();
    phonenumber_ = phonenumber;
  } else {
    clear_has_phonenumber();
    phonenumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:network.EmployeeInfo.phonenumber)
}

// optional int32 salary = 5;
inline bool EmployeeInfo::has_salary() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EmployeeInfo::set_has_salary() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EmployeeInfo::clear_has_salary() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EmployeeInfo::clear_salary() {
  salary_ = 0;
  clear_has_salary();
}
inline ::google::protobuf::int32 EmployeeInfo::salary() const {
  // @@protoc_insertion_point(field_get:network.EmployeeInfo.salary)
  return salary_;
}
inline void EmployeeInfo::set_salary(::google::protobuf::int32 value) {
  set_has_salary();
  salary_ = value;
  // @@protoc_insertion_point(field_set:network.EmployeeInfo.salary)
}

// optional string position = 6;
inline bool EmployeeInfo::has_position() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void EmployeeInfo::set_has_position() {
  _has_bits_[0] |= 0x00000020u;
}
inline void EmployeeInfo::clear_has_position() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void EmployeeInfo::clear_position() {
  if (position_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    position_->clear();
  }
  clear_has_position();
}
inline const ::std::string& EmployeeInfo::position() const {
  // @@protoc_insertion_point(field_get:network.EmployeeInfo.position)
  return *position_;
}
inline void EmployeeInfo::set_position(const ::std::string& value) {
  set_has_position();
  if (position_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    position_ = new ::std::string;
  }
  position_->assign(value);
  // @@protoc_insertion_point(field_set:network.EmployeeInfo.position)
}
inline void EmployeeInfo::set_position(const char* value) {
  set_has_position();
  if (position_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    position_ = new ::std::string;
  }
  position_->assign(value);
  // @@protoc_insertion_point(field_set_char:network.EmployeeInfo.position)
}
inline void EmployeeInfo::set_position(const char* value, size_t size) {
  set_has_position();
  if (position_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    position_ = new ::std::string;
  }
  position_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:network.EmployeeInfo.position)
}
inline ::std::string* EmployeeInfo::mutable_position() {
  set_has_position();
  if (position_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    position_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:network.EmployeeInfo.position)
  return position_;
}
inline ::std::string* EmployeeInfo::release_position() {
  clear_has_position();
  if (position_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = position_;
    position_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void EmployeeInfo::set_allocated_position(::std::string* position) {
  if (position_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete position_;
  }
  if (position) {
    set_has_position();
    position_ = position;
  } else {
    clear_has_position();
    position_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:network.EmployeeInfo.position)
}

// optional int32 hotelId = 7;
inline bool EmployeeInfo::has_hotelid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void EmployeeInfo::set_has_hotelid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void EmployeeInfo::clear_has_hotelid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void EmployeeInfo::clear_hotelid() {
  hotelid_ = 0;
  clear_has_hotelid();
}
inline ::google::protobuf::int32 EmployeeInfo::hotelid() const {
  // @@protoc_insertion_point(field_get:network.EmployeeInfo.hotelId)
  return hotelid_;
}
inline void EmployeeInfo::set_hotelid(::google::protobuf::int32 value) {
  set_has_hotelid();
  hotelid_ = value;
  // @@protoc_insertion_point(field_set:network.EmployeeInfo.hotelId)
}

// optional int32 id = 8;
inline bool EmployeeInfo::has_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void EmployeeInfo::set_has_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void EmployeeInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void EmployeeInfo::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 EmployeeInfo::id() const {
  // @@protoc_insertion_point(field_get:network.EmployeeInfo.id)
  return id_;
}
inline void EmployeeInfo::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:network.EmployeeInfo.id)
}

// -------------------------------------------------------------------

// EmployeesMessageResponse

// repeated .network.EmployeeInfo employees = 1;
inline int EmployeesMessageResponse::employees_size() const {
  return employees_.size();
}
inline void EmployeesMessageResponse::clear_employees() {
  employees_.Clear();
}
inline const ::network::EmployeeInfo& EmployeesMessageResponse::employees(int index) const {
  // @@protoc_insertion_point(field_get:network.EmployeesMessageResponse.employees)
  return employees_.Get(index);
}
inline ::network::EmployeeInfo* EmployeesMessageResponse::mutable_employees(int index) {
  // @@protoc_insertion_point(field_mutable:network.EmployeesMessageResponse.employees)
  return employees_.Mutable(index);
}
inline ::network::EmployeeInfo* EmployeesMessageResponse::add_employees() {
  // @@protoc_insertion_point(field_add:network.EmployeesMessageResponse.employees)
  return employees_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::network::EmployeeInfo >&
EmployeesMessageResponse::employees() const {
  // @@protoc_insertion_point(field_list:network.EmployeesMessageResponse.employees)
  return employees_;
}
inline ::google::protobuf::RepeatedPtrField< ::network::EmployeeInfo >*
EmployeesMessageResponse::mutable_employees() {
  // @@protoc_insertion_point(field_mutable_list:network.EmployeesMessageResponse.employees)
  return &employees_;
}

// -------------------------------------------------------------------

// HotelId

// optional int32 hotelId = 1;
inline bool HotelId::has_hotelid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HotelId::set_has_hotelid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HotelId::clear_has_hotelid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HotelId::clear_hotelid() {
  hotelid_ = 0;
  clear_has_hotelid();
}
inline ::google::protobuf::int32 HotelId::hotelid() const {
  // @@protoc_insertion_point(field_get:network.HotelId.hotelId)
  return hotelid_;
}
inline void HotelId::set_hotelid(::google::protobuf::int32 value) {
  set_has_hotelid();
  hotelid_ = value;
  // @@protoc_insertion_point(field_set:network.HotelId.hotelId)
}

// -------------------------------------------------------------------

// HotelInfo

// optional string name = 1;
inline bool HotelInfo::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HotelInfo::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HotelInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HotelInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& HotelInfo::name() const {
  // @@protoc_insertion_point(field_get:network.HotelInfo.name)
  return *name_;
}
inline void HotelInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:network.HotelInfo.name)
}
inline void HotelInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:network.HotelInfo.name)
}
inline void HotelInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:network.HotelInfo.name)
}
inline ::std::string* HotelInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:network.HotelInfo.name)
  return name_;
}
inline ::std::string* HotelInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void HotelInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:network.HotelInfo.name)
}

// optional string city = 2;
inline bool HotelInfo::has_city() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HotelInfo::set_has_city() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HotelInfo::clear_has_city() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HotelInfo::clear_city() {
  if (city_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_->clear();
  }
  clear_has_city();
}
inline const ::std::string& HotelInfo::city() const {
  // @@protoc_insertion_point(field_get:network.HotelInfo.city)
  return *city_;
}
inline void HotelInfo::set_city(const ::std::string& value) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_ = new ::std::string;
  }
  city_->assign(value);
  // @@protoc_insertion_point(field_set:network.HotelInfo.city)
}
inline void HotelInfo::set_city(const char* value) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_ = new ::std::string;
  }
  city_->assign(value);
  // @@protoc_insertion_point(field_set_char:network.HotelInfo.city)
}
inline void HotelInfo::set_city(const char* value, size_t size) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_ = new ::std::string;
  }
  city_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:network.HotelInfo.city)
}
inline ::std::string* HotelInfo::mutable_city() {
  set_has_city();
  if (city_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:network.HotelInfo.city)
  return city_;
}
inline ::std::string* HotelInfo::release_city() {
  clear_has_city();
  if (city_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = city_;
    city_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void HotelInfo::set_allocated_city(::std::string* city) {
  if (city_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete city_;
  }
  if (city) {
    set_has_city();
    city_ = city;
  } else {
    clear_has_city();
    city_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:network.HotelInfo.city)
}

// optional string street = 3;
inline bool HotelInfo::has_street() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HotelInfo::set_has_street() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HotelInfo::clear_has_street() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HotelInfo::clear_street() {
  if (street_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    street_->clear();
  }
  clear_has_street();
}
inline const ::std::string& HotelInfo::street() const {
  // @@protoc_insertion_point(field_get:network.HotelInfo.street)
  return *street_;
}
inline void HotelInfo::set_street(const ::std::string& value) {
  set_has_street();
  if (street_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    street_ = new ::std::string;
  }
  street_->assign(value);
  // @@protoc_insertion_point(field_set:network.HotelInfo.street)
}
inline void HotelInfo::set_street(const char* value) {
  set_has_street();
  if (street_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    street_ = new ::std::string;
  }
  street_->assign(value);
  // @@protoc_insertion_point(field_set_char:network.HotelInfo.street)
}
inline void HotelInfo::set_street(const char* value, size_t size) {
  set_has_street();
  if (street_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    street_ = new ::std::string;
  }
  street_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:network.HotelInfo.street)
}
inline ::std::string* HotelInfo::mutable_street() {
  set_has_street();
  if (street_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    street_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:network.HotelInfo.street)
  return street_;
}
inline ::std::string* HotelInfo::release_street() {
  clear_has_street();
  if (street_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = street_;
    street_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void HotelInfo::set_allocated_street(::std::string* street) {
  if (street_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete street_;
  }
  if (street) {
    set_has_street();
    street_ = street;
  } else {
    clear_has_street();
    street_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:network.HotelInfo.street)
}

// optional string phonenumber = 4;
inline bool HotelInfo::has_phonenumber() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HotelInfo::set_has_phonenumber() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HotelInfo::clear_has_phonenumber() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HotelInfo::clear_phonenumber() {
  if (phonenumber_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    phonenumber_->clear();
  }
  clear_has_phonenumber();
}
inline const ::std::string& HotelInfo::phonenumber() const {
  // @@protoc_insertion_point(field_get:network.HotelInfo.phonenumber)
  return *phonenumber_;
}
inline void HotelInfo::set_phonenumber(const ::std::string& value) {
  set_has_phonenumber();
  if (phonenumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    phonenumber_ = new ::std::string;
  }
  phonenumber_->assign(value);
  // @@protoc_insertion_point(field_set:network.HotelInfo.phonenumber)
}
inline void HotelInfo::set_phonenumber(const char* value) {
  set_has_phonenumber();
  if (phonenumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    phonenumber_ = new ::std::string;
  }
  phonenumber_->assign(value);
  // @@protoc_insertion_point(field_set_char:network.HotelInfo.phonenumber)
}
inline void HotelInfo::set_phonenumber(const char* value, size_t size) {
  set_has_phonenumber();
  if (phonenumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    phonenumber_ = new ::std::string;
  }
  phonenumber_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:network.HotelInfo.phonenumber)
}
inline ::std::string* HotelInfo::mutable_phonenumber() {
  set_has_phonenumber();
  if (phonenumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    phonenumber_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:network.HotelInfo.phonenumber)
  return phonenumber_;
}
inline ::std::string* HotelInfo::release_phonenumber() {
  clear_has_phonenumber();
  if (phonenumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = phonenumber_;
    phonenumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void HotelInfo::set_allocated_phonenumber(::std::string* phonenumber) {
  if (phonenumber_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete phonenumber_;
  }
  if (phonenumber) {
    set_has_phonenumber();
    phonenumber_ = phonenumber;
  } else {
    clear_has_phonenumber();
    phonenumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:network.HotelInfo.phonenumber)
}

// optional string email = 5;
inline bool HotelInfo::has_email() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void HotelInfo::set_has_email() {
  _has_bits_[0] |= 0x00000010u;
}
inline void HotelInfo::clear_has_email() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void HotelInfo::clear_email() {
  if (email_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    email_->clear();
  }
  clear_has_email();
}
inline const ::std::string& HotelInfo::email() const {
  // @@protoc_insertion_point(field_get:network.HotelInfo.email)
  return *email_;
}
inline void HotelInfo::set_email(const ::std::string& value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    email_ = new ::std::string;
  }
  email_->assign(value);
  // @@protoc_insertion_point(field_set:network.HotelInfo.email)
}
inline void HotelInfo::set_email(const char* value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    email_ = new ::std::string;
  }
  email_->assign(value);
  // @@protoc_insertion_point(field_set_char:network.HotelInfo.email)
}
inline void HotelInfo::set_email(const char* value, size_t size) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    email_ = new ::std::string;
  }
  email_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:network.HotelInfo.email)
}
inline ::std::string* HotelInfo::mutable_email() {
  set_has_email();
  if (email_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    email_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:network.HotelInfo.email)
  return email_;
}
inline ::std::string* HotelInfo::release_email() {
  clear_has_email();
  if (email_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = email_;
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void HotelInfo::set_allocated_email(::std::string* email) {
  if (email_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete email_;
  }
  if (email) {
    set_has_email();
    email_ = email;
  } else {
    clear_has_email();
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:network.HotelInfo.email)
}

// optional int32 stars = 6;
inline bool HotelInfo::has_stars() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void HotelInfo::set_has_stars() {
  _has_bits_[0] |= 0x00000020u;
}
inline void HotelInfo::clear_has_stars() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void HotelInfo::clear_stars() {
  stars_ = 0;
  clear_has_stars();
}
inline ::google::protobuf::int32 HotelInfo::stars() const {
  // @@protoc_insertion_point(field_get:network.HotelInfo.stars)
  return stars_;
}
inline void HotelInfo::set_stars(::google::protobuf::int32 value) {
  set_has_stars();
  stars_ = value;
  // @@protoc_insertion_point(field_set:network.HotelInfo.stars)
}

// optional string type = 7;
inline bool HotelInfo::has_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void HotelInfo::set_has_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void HotelInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void HotelInfo::clear_type() {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& HotelInfo::type() const {
  // @@protoc_insertion_point(field_get:network.HotelInfo.type)
  return *type_;
}
inline void HotelInfo::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set:network.HotelInfo.type)
}
inline void HotelInfo::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set_char:network.HotelInfo.type)
}
inline void HotelInfo::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:network.HotelInfo.type)
}
inline ::std::string* HotelInfo::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:network.HotelInfo.type)
  return type_;
}
inline ::std::string* HotelInfo::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void HotelInfo::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:network.HotelInfo.type)
}

// -------------------------------------------------------------------

// HotelsMessageResponse

// repeated .network.HotelInfo hotels = 1;
inline int HotelsMessageResponse::hotels_size() const {
  return hotels_.size();
}
inline void HotelsMessageResponse::clear_hotels() {
  hotels_.Clear();
}
inline const ::network::HotelInfo& HotelsMessageResponse::hotels(int index) const {
  // @@protoc_insertion_point(field_get:network.HotelsMessageResponse.hotels)
  return hotels_.Get(index);
}
inline ::network::HotelInfo* HotelsMessageResponse::mutable_hotels(int index) {
  // @@protoc_insertion_point(field_mutable:network.HotelsMessageResponse.hotels)
  return hotels_.Mutable(index);
}
inline ::network::HotelInfo* HotelsMessageResponse::add_hotels() {
  // @@protoc_insertion_point(field_add:network.HotelsMessageResponse.hotels)
  return hotels_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::network::HotelInfo >&
HotelsMessageResponse::hotels() const {
  // @@protoc_insertion_point(field_list:network.HotelsMessageResponse.hotels)
  return hotels_;
}
inline ::google::protobuf::RepeatedPtrField< ::network::HotelInfo >*
HotelsMessageResponse::mutable_hotels() {
  // @@protoc_insertion_point(field_mutable_list:network.HotelsMessageResponse.hotels)
  return &hotels_;
}

// -------------------------------------------------------------------

// RoomInfo

// optional int32 places = 1;
inline bool RoomInfo::has_places() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoomInfo::set_has_places() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoomInfo::clear_has_places() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoomInfo::clear_places() {
  places_ = 0;
  clear_has_places();
}
inline ::google::protobuf::int32 RoomInfo::places() const {
  // @@protoc_insertion_point(field_get:network.RoomInfo.places)
  return places_;
}
inline void RoomInfo::set_places(::google::protobuf::int32 value) {
  set_has_places();
  places_ = value;
  // @@protoc_insertion_point(field_set:network.RoomInfo.places)
}

// optional int32 price = 2;
inline bool RoomInfo::has_price() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoomInfo::set_has_price() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoomInfo::clear_has_price() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoomInfo::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline ::google::protobuf::int32 RoomInfo::price() const {
  // @@protoc_insertion_point(field_get:network.RoomInfo.price)
  return price_;
}
inline void RoomInfo::set_price(::google::protobuf::int32 value) {
  set_has_price();
  price_ = value;
  // @@protoc_insertion_point(field_set:network.RoomInfo.price)
}

// optional int32 rating = 3;
inline bool RoomInfo::has_rating() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RoomInfo::set_has_rating() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RoomInfo::clear_has_rating() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RoomInfo::clear_rating() {
  rating_ = 0;
  clear_has_rating();
}
inline ::google::protobuf::int32 RoomInfo::rating() const {
  // @@protoc_insertion_point(field_get:network.RoomInfo.rating)
  return rating_;
}
inline void RoomInfo::set_rating(::google::protobuf::int32 value) {
  set_has_rating();
  rating_ = value;
  // @@protoc_insertion_point(field_set:network.RoomInfo.rating)
}

// optional bool status = 4;
inline bool RoomInfo::has_status() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RoomInfo::set_has_status() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RoomInfo::clear_has_status() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RoomInfo::clear_status() {
  status_ = false;
  clear_has_status();
}
inline bool RoomInfo::status() const {
  // @@protoc_insertion_point(field_get:network.RoomInfo.status)
  return status_;
}
inline void RoomInfo::set_status(bool value) {
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:network.RoomInfo.status)
}

// optional int32 floor = 5;
inline bool RoomInfo::has_floor() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RoomInfo::set_has_floor() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RoomInfo::clear_has_floor() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RoomInfo::clear_floor() {
  floor_ = 0;
  clear_has_floor();
}
inline ::google::protobuf::int32 RoomInfo::floor() const {
  // @@protoc_insertion_point(field_get:network.RoomInfo.floor)
  return floor_;
}
inline void RoomInfo::set_floor(::google::protobuf::int32 value) {
  set_has_floor();
  floor_ = value;
  // @@protoc_insertion_point(field_set:network.RoomInfo.floor)
}

// optional string type = 6;
inline bool RoomInfo::has_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RoomInfo::set_has_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RoomInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RoomInfo::clear_type() {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& RoomInfo::type() const {
  // @@protoc_insertion_point(field_get:network.RoomInfo.type)
  return *type_;
}
inline void RoomInfo::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set:network.RoomInfo.type)
}
inline void RoomInfo::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set_char:network.RoomInfo.type)
}
inline void RoomInfo::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:network.RoomInfo.type)
}
inline ::std::string* RoomInfo::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:network.RoomInfo.type)
  return type_;
}
inline ::std::string* RoomInfo::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RoomInfo::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:network.RoomInfo.type)
}

// optional int32 hotelID = 7;
inline bool RoomInfo::has_hotelid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RoomInfo::set_has_hotelid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RoomInfo::clear_has_hotelid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RoomInfo::clear_hotelid() {
  hotelid_ = 0;
  clear_has_hotelid();
}
inline ::google::protobuf::int32 RoomInfo::hotelid() const {
  // @@protoc_insertion_point(field_get:network.RoomInfo.hotelID)
  return hotelid_;
}
inline void RoomInfo::set_hotelid(::google::protobuf::int32 value) {
  set_has_hotelid();
  hotelid_ = value;
  // @@protoc_insertion_point(field_set:network.RoomInfo.hotelID)
}

// optional int32 id = 8;
inline bool RoomInfo::has_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RoomInfo::set_has_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RoomInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RoomInfo::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 RoomInfo::id() const {
  // @@protoc_insertion_point(field_get:network.RoomInfo.id)
  return id_;
}
inline void RoomInfo::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:network.RoomInfo.id)
}

// -------------------------------------------------------------------

// RoomsMessageResponse

// repeated .network.RoomInfo rooms = 1;
inline int RoomsMessageResponse::rooms_size() const {
  return rooms_.size();
}
inline void RoomsMessageResponse::clear_rooms() {
  rooms_.Clear();
}
inline const ::network::RoomInfo& RoomsMessageResponse::rooms(int index) const {
  // @@protoc_insertion_point(field_get:network.RoomsMessageResponse.rooms)
  return rooms_.Get(index);
}
inline ::network::RoomInfo* RoomsMessageResponse::mutable_rooms(int index) {
  // @@protoc_insertion_point(field_mutable:network.RoomsMessageResponse.rooms)
  return rooms_.Mutable(index);
}
inline ::network::RoomInfo* RoomsMessageResponse::add_rooms() {
  // @@protoc_insertion_point(field_add:network.RoomsMessageResponse.rooms)
  return rooms_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::network::RoomInfo >&
RoomsMessageResponse::rooms() const {
  // @@protoc_insertion_point(field_list:network.RoomsMessageResponse.rooms)
  return rooms_;
}
inline ::google::protobuf::RepeatedPtrField< ::network::RoomInfo >*
RoomsMessageResponse::mutable_rooms() {
  // @@protoc_insertion_point(field_mutable_list:network.RoomsMessageResponse.rooms)
  return &rooms_;
}

// -------------------------------------------------------------------

// VacantRooms

// optional int32 places = 1;
inline bool VacantRooms::has_places() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VacantRooms::set_has_places() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VacantRooms::clear_has_places() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VacantRooms::clear_places() {
  places_ = 0;
  clear_has_places();
}
inline ::google::protobuf::int32 VacantRooms::places() const {
  // @@protoc_insertion_point(field_get:network.VacantRooms.places)
  return places_;
}
inline void VacantRooms::set_places(::google::protobuf::int32 value) {
  set_has_places();
  places_ = value;
  // @@protoc_insertion_point(field_set:network.VacantRooms.places)
}

// optional int32 begin_price = 2;
inline bool VacantRooms::has_begin_price() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VacantRooms::set_has_begin_price() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VacantRooms::clear_has_begin_price() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VacantRooms::clear_begin_price() {
  begin_price_ = 0;
  clear_has_begin_price();
}
inline ::google::protobuf::int32 VacantRooms::begin_price() const {
  // @@protoc_insertion_point(field_get:network.VacantRooms.begin_price)
  return begin_price_;
}
inline void VacantRooms::set_begin_price(::google::protobuf::int32 value) {
  set_has_begin_price();
  begin_price_ = value;
  // @@protoc_insertion_point(field_set:network.VacantRooms.begin_price)
}

// optional int32 end_price = 3;
inline bool VacantRooms::has_end_price() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VacantRooms::set_has_end_price() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VacantRooms::clear_has_end_price() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VacantRooms::clear_end_price() {
  end_price_ = 0;
  clear_has_end_price();
}
inline ::google::protobuf::int32 VacantRooms::end_price() const {
  // @@protoc_insertion_point(field_get:network.VacantRooms.end_price)
  return end_price_;
}
inline void VacantRooms::set_end_price(::google::protobuf::int32 value) {
  set_has_end_price();
  end_price_ = value;
  // @@protoc_insertion_point(field_set:network.VacantRooms.end_price)
}

// optional string datebegin = 5;
inline bool VacantRooms::has_datebegin() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VacantRooms::set_has_datebegin() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VacantRooms::clear_has_datebegin() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VacantRooms::clear_datebegin() {
  if (datebegin_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    datebegin_->clear();
  }
  clear_has_datebegin();
}
inline const ::std::string& VacantRooms::datebegin() const {
  // @@protoc_insertion_point(field_get:network.VacantRooms.datebegin)
  return *datebegin_;
}
inline void VacantRooms::set_datebegin(const ::std::string& value) {
  set_has_datebegin();
  if (datebegin_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    datebegin_ = new ::std::string;
  }
  datebegin_->assign(value);
  // @@protoc_insertion_point(field_set:network.VacantRooms.datebegin)
}
inline void VacantRooms::set_datebegin(const char* value) {
  set_has_datebegin();
  if (datebegin_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    datebegin_ = new ::std::string;
  }
  datebegin_->assign(value);
  // @@protoc_insertion_point(field_set_char:network.VacantRooms.datebegin)
}
inline void VacantRooms::set_datebegin(const char* value, size_t size) {
  set_has_datebegin();
  if (datebegin_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    datebegin_ = new ::std::string;
  }
  datebegin_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:network.VacantRooms.datebegin)
}
inline ::std::string* VacantRooms::mutable_datebegin() {
  set_has_datebegin();
  if (datebegin_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    datebegin_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:network.VacantRooms.datebegin)
  return datebegin_;
}
inline ::std::string* VacantRooms::release_datebegin() {
  clear_has_datebegin();
  if (datebegin_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = datebegin_;
    datebegin_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void VacantRooms::set_allocated_datebegin(::std::string* datebegin) {
  if (datebegin_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete datebegin_;
  }
  if (datebegin) {
    set_has_datebegin();
    datebegin_ = datebegin;
  } else {
    clear_has_datebegin();
    datebegin_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:network.VacantRooms.datebegin)
}

// optional string dateend = 6;
inline bool VacantRooms::has_dateend() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void VacantRooms::set_has_dateend() {
  _has_bits_[0] |= 0x00000010u;
}
inline void VacantRooms::clear_has_dateend() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void VacantRooms::clear_dateend() {
  if (dateend_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dateend_->clear();
  }
  clear_has_dateend();
}
inline const ::std::string& VacantRooms::dateend() const {
  // @@protoc_insertion_point(field_get:network.VacantRooms.dateend)
  return *dateend_;
}
inline void VacantRooms::set_dateend(const ::std::string& value) {
  set_has_dateend();
  if (dateend_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dateend_ = new ::std::string;
  }
  dateend_->assign(value);
  // @@protoc_insertion_point(field_set:network.VacantRooms.dateend)
}
inline void VacantRooms::set_dateend(const char* value) {
  set_has_dateend();
  if (dateend_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dateend_ = new ::std::string;
  }
  dateend_->assign(value);
  // @@protoc_insertion_point(field_set_char:network.VacantRooms.dateend)
}
inline void VacantRooms::set_dateend(const char* value, size_t size) {
  set_has_dateend();
  if (dateend_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dateend_ = new ::std::string;
  }
  dateend_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:network.VacantRooms.dateend)
}
inline ::std::string* VacantRooms::mutable_dateend() {
  set_has_dateend();
  if (dateend_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dateend_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:network.VacantRooms.dateend)
  return dateend_;
}
inline ::std::string* VacantRooms::release_dateend() {
  clear_has_dateend();
  if (dateend_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = dateend_;
    dateend_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void VacantRooms::set_allocated_dateend(::std::string* dateend) {
  if (dateend_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete dateend_;
  }
  if (dateend) {
    set_has_dateend();
    dateend_ = dateend;
  } else {
    clear_has_dateend();
    dateend_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:network.VacantRooms.dateend)
}

// optional int32 hotelID = 7;
inline bool VacantRooms::has_hotelid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void VacantRooms::set_has_hotelid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void VacantRooms::clear_has_hotelid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void VacantRooms::clear_hotelid() {
  hotelid_ = 0;
  clear_has_hotelid();
}
inline ::google::protobuf::int32 VacantRooms::hotelid() const {
  // @@protoc_insertion_point(field_get:network.VacantRooms.hotelID)
  return hotelid_;
}
inline void VacantRooms::set_hotelid(::google::protobuf::int32 value) {
  set_has_hotelid();
  hotelid_ = value;
  // @@protoc_insertion_point(field_set:network.VacantRooms.hotelID)
}

// optional int32 begin_rating = 8;
inline bool VacantRooms::has_begin_rating() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void VacantRooms::set_has_begin_rating() {
  _has_bits_[0] |= 0x00000040u;
}
inline void VacantRooms::clear_has_begin_rating() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void VacantRooms::clear_begin_rating() {
  begin_rating_ = 0;
  clear_has_begin_rating();
}
inline ::google::protobuf::int32 VacantRooms::begin_rating() const {
  // @@protoc_insertion_point(field_get:network.VacantRooms.begin_rating)
  return begin_rating_;
}
inline void VacantRooms::set_begin_rating(::google::protobuf::int32 value) {
  set_has_begin_rating();
  begin_rating_ = value;
  // @@protoc_insertion_point(field_set:network.VacantRooms.begin_rating)
}

// optional int32 end_rating = 9;
inline bool VacantRooms::has_end_rating() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void VacantRooms::set_has_end_rating() {
  _has_bits_[0] |= 0x00000080u;
}
inline void VacantRooms::clear_has_end_rating() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void VacantRooms::clear_end_rating() {
  end_rating_ = 0;
  clear_has_end_rating();
}
inline ::google::protobuf::int32 VacantRooms::end_rating() const {
  // @@protoc_insertion_point(field_get:network.VacantRooms.end_rating)
  return end_rating_;
}
inline void VacantRooms::set_end_rating(::google::protobuf::int32 value) {
  set_has_end_rating();
  end_rating_ = value;
  // @@protoc_insertion_point(field_set:network.VacantRooms.end_rating)
}

// optional string room_type = 10;
inline bool VacantRooms::has_room_type() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void VacantRooms::set_has_room_type() {
  _has_bits_[0] |= 0x00000100u;
}
inline void VacantRooms::clear_has_room_type() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void VacantRooms::clear_room_type() {
  if (room_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    room_type_->clear();
  }
  clear_has_room_type();
}
inline const ::std::string& VacantRooms::room_type() const {
  // @@protoc_insertion_point(field_get:network.VacantRooms.room_type)
  return *room_type_;
}
inline void VacantRooms::set_room_type(const ::std::string& value) {
  set_has_room_type();
  if (room_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    room_type_ = new ::std::string;
  }
  room_type_->assign(value);
  // @@protoc_insertion_point(field_set:network.VacantRooms.room_type)
}
inline void VacantRooms::set_room_type(const char* value) {
  set_has_room_type();
  if (room_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    room_type_ = new ::std::string;
  }
  room_type_->assign(value);
  // @@protoc_insertion_point(field_set_char:network.VacantRooms.room_type)
}
inline void VacantRooms::set_room_type(const char* value, size_t size) {
  set_has_room_type();
  if (room_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    room_type_ = new ::std::string;
  }
  room_type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:network.VacantRooms.room_type)
}
inline ::std::string* VacantRooms::mutable_room_type() {
  set_has_room_type();
  if (room_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    room_type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:network.VacantRooms.room_type)
  return room_type_;
}
inline ::std::string* VacantRooms::release_room_type() {
  clear_has_room_type();
  if (room_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = room_type_;
    room_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void VacantRooms::set_allocated_room_type(::std::string* room_type) {
  if (room_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete room_type_;
  }
  if (room_type) {
    set_has_room_type();
    room_type_ = room_type;
  } else {
    clear_has_room_type();
    room_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:network.VacantRooms.room_type)
}

// -------------------------------------------------------------------

// OrderInfo

// optional int32 id = 1;
inline bool OrderInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OrderInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OrderInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OrderInfo::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 OrderInfo::id() const {
  // @@protoc_insertion_point(field_get:network.OrderInfo.id)
  return id_;
}
inline void OrderInfo::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:network.OrderInfo.id)
}

// optional string startdate = 2;
inline bool OrderInfo::has_startdate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OrderInfo::set_has_startdate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OrderInfo::clear_has_startdate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OrderInfo::clear_startdate() {
  if (startdate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    startdate_->clear();
  }
  clear_has_startdate();
}
inline const ::std::string& OrderInfo::startdate() const {
  // @@protoc_insertion_point(field_get:network.OrderInfo.startdate)
  return *startdate_;
}
inline void OrderInfo::set_startdate(const ::std::string& value) {
  set_has_startdate();
  if (startdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    startdate_ = new ::std::string;
  }
  startdate_->assign(value);
  // @@protoc_insertion_point(field_set:network.OrderInfo.startdate)
}
inline void OrderInfo::set_startdate(const char* value) {
  set_has_startdate();
  if (startdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    startdate_ = new ::std::string;
  }
  startdate_->assign(value);
  // @@protoc_insertion_point(field_set_char:network.OrderInfo.startdate)
}
inline void OrderInfo::set_startdate(const char* value, size_t size) {
  set_has_startdate();
  if (startdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    startdate_ = new ::std::string;
  }
  startdate_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:network.OrderInfo.startdate)
}
inline ::std::string* OrderInfo::mutable_startdate() {
  set_has_startdate();
  if (startdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    startdate_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:network.OrderInfo.startdate)
  return startdate_;
}
inline ::std::string* OrderInfo::release_startdate() {
  clear_has_startdate();
  if (startdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = startdate_;
    startdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OrderInfo::set_allocated_startdate(::std::string* startdate) {
  if (startdate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete startdate_;
  }
  if (startdate) {
    set_has_startdate();
    startdate_ = startdate;
  } else {
    clear_has_startdate();
    startdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:network.OrderInfo.startdate)
}

// optional string enddate = 3;
inline bool OrderInfo::has_enddate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OrderInfo::set_has_enddate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OrderInfo::clear_has_enddate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OrderInfo::clear_enddate() {
  if (enddate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    enddate_->clear();
  }
  clear_has_enddate();
}
inline const ::std::string& OrderInfo::enddate() const {
  // @@protoc_insertion_point(field_get:network.OrderInfo.enddate)
  return *enddate_;
}
inline void OrderInfo::set_enddate(const ::std::string& value) {
  set_has_enddate();
  if (enddate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    enddate_ = new ::std::string;
  }
  enddate_->assign(value);
  // @@protoc_insertion_point(field_set:network.OrderInfo.enddate)
}
inline void OrderInfo::set_enddate(const char* value) {
  set_has_enddate();
  if (enddate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    enddate_ = new ::std::string;
  }
  enddate_->assign(value);
  // @@protoc_insertion_point(field_set_char:network.OrderInfo.enddate)
}
inline void OrderInfo::set_enddate(const char* value, size_t size) {
  set_has_enddate();
  if (enddate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    enddate_ = new ::std::string;
  }
  enddate_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:network.OrderInfo.enddate)
}
inline ::std::string* OrderInfo::mutable_enddate() {
  set_has_enddate();
  if (enddate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    enddate_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:network.OrderInfo.enddate)
  return enddate_;
}
inline ::std::string* OrderInfo::release_enddate() {
  clear_has_enddate();
  if (enddate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = enddate_;
    enddate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OrderInfo::set_allocated_enddate(::std::string* enddate) {
  if (enddate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete enddate_;
  }
  if (enddate) {
    set_has_enddate();
    enddate_ = enddate;
  } else {
    clear_has_enddate();
    enddate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:network.OrderInfo.enddate)
}

// optional int32 idroom = 4;
inline bool OrderInfo::has_idroom() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OrderInfo::set_has_idroom() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OrderInfo::clear_has_idroom() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OrderInfo::clear_idroom() {
  idroom_ = 0;
  clear_has_idroom();
}
inline ::google::protobuf::int32 OrderInfo::idroom() const {
  // @@protoc_insertion_point(field_get:network.OrderInfo.idroom)
  return idroom_;
}
inline void OrderInfo::set_idroom(::google::protobuf::int32 value) {
  set_has_idroom();
  idroom_ = value;
  // @@protoc_insertion_point(field_set:network.OrderInfo.idroom)
}

// optional string employee_secondname = 5;
inline bool OrderInfo::has_employee_secondname() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OrderInfo::set_has_employee_secondname() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OrderInfo::clear_has_employee_secondname() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OrderInfo::clear_employee_secondname() {
  if (employee_secondname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    employee_secondname_->clear();
  }
  clear_has_employee_secondname();
}
inline const ::std::string& OrderInfo::employee_secondname() const {
  // @@protoc_insertion_point(field_get:network.OrderInfo.employee_secondname)
  return *employee_secondname_;
}
inline void OrderInfo::set_employee_secondname(const ::std::string& value) {
  set_has_employee_secondname();
  if (employee_secondname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    employee_secondname_ = new ::std::string;
  }
  employee_secondname_->assign(value);
  // @@protoc_insertion_point(field_set:network.OrderInfo.employee_secondname)
}
inline void OrderInfo::set_employee_secondname(const char* value) {
  set_has_employee_secondname();
  if (employee_secondname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    employee_secondname_ = new ::std::string;
  }
  employee_secondname_->assign(value);
  // @@protoc_insertion_point(field_set_char:network.OrderInfo.employee_secondname)
}
inline void OrderInfo::set_employee_secondname(const char* value, size_t size) {
  set_has_employee_secondname();
  if (employee_secondname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    employee_secondname_ = new ::std::string;
  }
  employee_secondname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:network.OrderInfo.employee_secondname)
}
inline ::std::string* OrderInfo::mutable_employee_secondname() {
  set_has_employee_secondname();
  if (employee_secondname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    employee_secondname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:network.OrderInfo.employee_secondname)
  return employee_secondname_;
}
inline ::std::string* OrderInfo::release_employee_secondname() {
  clear_has_employee_secondname();
  if (employee_secondname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = employee_secondname_;
    employee_secondname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OrderInfo::set_allocated_employee_secondname(::std::string* employee_secondname) {
  if (employee_secondname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete employee_secondname_;
  }
  if (employee_secondname) {
    set_has_employee_secondname();
    employee_secondname_ = employee_secondname;
  } else {
    clear_has_employee_secondname();
    employee_secondname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:network.OrderInfo.employee_secondname)
}

// optional string guest_secondname = 6;
inline bool OrderInfo::has_guest_secondname() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void OrderInfo::set_has_guest_secondname() {
  _has_bits_[0] |= 0x00000020u;
}
inline void OrderInfo::clear_has_guest_secondname() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void OrderInfo::clear_guest_secondname() {
  if (guest_secondname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    guest_secondname_->clear();
  }
  clear_has_guest_secondname();
}
inline const ::std::string& OrderInfo::guest_secondname() const {
  // @@protoc_insertion_point(field_get:network.OrderInfo.guest_secondname)
  return *guest_secondname_;
}
inline void OrderInfo::set_guest_secondname(const ::std::string& value) {
  set_has_guest_secondname();
  if (guest_secondname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    guest_secondname_ = new ::std::string;
  }
  guest_secondname_->assign(value);
  // @@protoc_insertion_point(field_set:network.OrderInfo.guest_secondname)
}
inline void OrderInfo::set_guest_secondname(const char* value) {
  set_has_guest_secondname();
  if (guest_secondname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    guest_secondname_ = new ::std::string;
  }
  guest_secondname_->assign(value);
  // @@protoc_insertion_point(field_set_char:network.OrderInfo.guest_secondname)
}
inline void OrderInfo::set_guest_secondname(const char* value, size_t size) {
  set_has_guest_secondname();
  if (guest_secondname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    guest_secondname_ = new ::std::string;
  }
  guest_secondname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:network.OrderInfo.guest_secondname)
}
inline ::std::string* OrderInfo::mutable_guest_secondname() {
  set_has_guest_secondname();
  if (guest_secondname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    guest_secondname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:network.OrderInfo.guest_secondname)
  return guest_secondname_;
}
inline ::std::string* OrderInfo::release_guest_secondname() {
  clear_has_guest_secondname();
  if (guest_secondname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = guest_secondname_;
    guest_secondname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OrderInfo::set_allocated_guest_secondname(::std::string* guest_secondname) {
  if (guest_secondname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete guest_secondname_;
  }
  if (guest_secondname) {
    set_has_guest_secondname();
    guest_secondname_ = guest_secondname;
  } else {
    clear_has_guest_secondname();
    guest_secondname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:network.OrderInfo.guest_secondname)
}

// optional int32 hotelID = 7;
inline bool OrderInfo::has_hotelid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void OrderInfo::set_has_hotelid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void OrderInfo::clear_has_hotelid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void OrderInfo::clear_hotelid() {
  hotelid_ = 0;
  clear_has_hotelid();
}
inline ::google::protobuf::int32 OrderInfo::hotelid() const {
  // @@protoc_insertion_point(field_get:network.OrderInfo.hotelID)
  return hotelid_;
}
inline void OrderInfo::set_hotelid(::google::protobuf::int32 value) {
  set_has_hotelid();
  hotelid_ = value;
  // @@protoc_insertion_point(field_set:network.OrderInfo.hotelID)
}

// optional int32 employee_id = 8;
inline bool OrderInfo::has_employee_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void OrderInfo::set_has_employee_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void OrderInfo::clear_has_employee_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void OrderInfo::clear_employee_id() {
  employee_id_ = 0;
  clear_has_employee_id();
}
inline ::google::protobuf::int32 OrderInfo::employee_id() const {
  // @@protoc_insertion_point(field_get:network.OrderInfo.employee_id)
  return employee_id_;
}
inline void OrderInfo::set_employee_id(::google::protobuf::int32 value) {
  set_has_employee_id();
  employee_id_ = value;
  // @@protoc_insertion_point(field_set:network.OrderInfo.employee_id)
}

// optional int32 guest_id = 9;
inline bool OrderInfo::has_guest_id() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void OrderInfo::set_has_guest_id() {
  _has_bits_[0] |= 0x00000100u;
}
inline void OrderInfo::clear_has_guest_id() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void OrderInfo::clear_guest_id() {
  guest_id_ = 0;
  clear_has_guest_id();
}
inline ::google::protobuf::int32 OrderInfo::guest_id() const {
  // @@protoc_insertion_point(field_get:network.OrderInfo.guest_id)
  return guest_id_;
}
inline void OrderInfo::set_guest_id(::google::protobuf::int32 value) {
  set_has_guest_id();
  guest_id_ = value;
  // @@protoc_insertion_point(field_set:network.OrderInfo.guest_id)
}

// -------------------------------------------------------------------

// OrdersMessageResponse

// repeated .network.OrderInfo orders = 1;
inline int OrdersMessageResponse::orders_size() const {
  return orders_.size();
}
inline void OrdersMessageResponse::clear_orders() {
  orders_.Clear();
}
inline const ::network::OrderInfo& OrdersMessageResponse::orders(int index) const {
  // @@protoc_insertion_point(field_get:network.OrdersMessageResponse.orders)
  return orders_.Get(index);
}
inline ::network::OrderInfo* OrdersMessageResponse::mutable_orders(int index) {
  // @@protoc_insertion_point(field_mutable:network.OrdersMessageResponse.orders)
  return orders_.Mutable(index);
}
inline ::network::OrderInfo* OrdersMessageResponse::add_orders() {
  // @@protoc_insertion_point(field_add:network.OrdersMessageResponse.orders)
  return orders_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::network::OrderInfo >&
OrdersMessageResponse::orders() const {
  // @@protoc_insertion_point(field_list:network.OrdersMessageResponse.orders)
  return orders_;
}
inline ::google::protobuf::RepeatedPtrField< ::network::OrderInfo >*
OrdersMessageResponse::mutable_orders() {
  // @@protoc_insertion_point(field_mutable_list:network.OrdersMessageResponse.orders)
  return &orders_;
}

// -------------------------------------------------------------------

// GuestOrderInfo

// optional string startdate = 1;
inline bool GuestOrderInfo::has_startdate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GuestOrderInfo::set_has_startdate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GuestOrderInfo::clear_has_startdate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GuestOrderInfo::clear_startdate() {
  if (startdate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    startdate_->clear();
  }
  clear_has_startdate();
}
inline const ::std::string& GuestOrderInfo::startdate() const {
  // @@protoc_insertion_point(field_get:network.GuestOrderInfo.startdate)
  return *startdate_;
}
inline void GuestOrderInfo::set_startdate(const ::std::string& value) {
  set_has_startdate();
  if (startdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    startdate_ = new ::std::string;
  }
  startdate_->assign(value);
  // @@protoc_insertion_point(field_set:network.GuestOrderInfo.startdate)
}
inline void GuestOrderInfo::set_startdate(const char* value) {
  set_has_startdate();
  if (startdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    startdate_ = new ::std::string;
  }
  startdate_->assign(value);
  // @@protoc_insertion_point(field_set_char:network.GuestOrderInfo.startdate)
}
inline void GuestOrderInfo::set_startdate(const char* value, size_t size) {
  set_has_startdate();
  if (startdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    startdate_ = new ::std::string;
  }
  startdate_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:network.GuestOrderInfo.startdate)
}
inline ::std::string* GuestOrderInfo::mutable_startdate() {
  set_has_startdate();
  if (startdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    startdate_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:network.GuestOrderInfo.startdate)
  return startdate_;
}
inline ::std::string* GuestOrderInfo::release_startdate() {
  clear_has_startdate();
  if (startdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = startdate_;
    startdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GuestOrderInfo::set_allocated_startdate(::std::string* startdate) {
  if (startdate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete startdate_;
  }
  if (startdate) {
    set_has_startdate();
    startdate_ = startdate;
  } else {
    clear_has_startdate();
    startdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:network.GuestOrderInfo.startdate)
}

// optional string enddate = 2;
inline bool GuestOrderInfo::has_enddate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GuestOrderInfo::set_has_enddate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GuestOrderInfo::clear_has_enddate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GuestOrderInfo::clear_enddate() {
  if (enddate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    enddate_->clear();
  }
  clear_has_enddate();
}
inline const ::std::string& GuestOrderInfo::enddate() const {
  // @@protoc_insertion_point(field_get:network.GuestOrderInfo.enddate)
  return *enddate_;
}
inline void GuestOrderInfo::set_enddate(const ::std::string& value) {
  set_has_enddate();
  if (enddate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    enddate_ = new ::std::string;
  }
  enddate_->assign(value);
  // @@protoc_insertion_point(field_set:network.GuestOrderInfo.enddate)
}
inline void GuestOrderInfo::set_enddate(const char* value) {
  set_has_enddate();
  if (enddate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    enddate_ = new ::std::string;
  }
  enddate_->assign(value);
  // @@protoc_insertion_point(field_set_char:network.GuestOrderInfo.enddate)
}
inline void GuestOrderInfo::set_enddate(const char* value, size_t size) {
  set_has_enddate();
  if (enddate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    enddate_ = new ::std::string;
  }
  enddate_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:network.GuestOrderInfo.enddate)
}
inline ::std::string* GuestOrderInfo::mutable_enddate() {
  set_has_enddate();
  if (enddate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    enddate_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:network.GuestOrderInfo.enddate)
  return enddate_;
}
inline ::std::string* GuestOrderInfo::release_enddate() {
  clear_has_enddate();
  if (enddate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = enddate_;
    enddate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GuestOrderInfo::set_allocated_enddate(::std::string* enddate) {
  if (enddate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete enddate_;
  }
  if (enddate) {
    set_has_enddate();
    enddate_ = enddate;
  } else {
    clear_has_enddate();
    enddate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:network.GuestOrderInfo.enddate)
}

// optional int32 idroom = 3;
inline bool GuestOrderInfo::has_idroom() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GuestOrderInfo::set_has_idroom() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GuestOrderInfo::clear_has_idroom() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GuestOrderInfo::clear_idroom() {
  idroom_ = 0;
  clear_has_idroom();
}
inline ::google::protobuf::int32 GuestOrderInfo::idroom() const {
  // @@protoc_insertion_point(field_get:network.GuestOrderInfo.idroom)
  return idroom_;
}
inline void GuestOrderInfo::set_idroom(::google::protobuf::int32 value) {
  set_has_idroom();
  idroom_ = value;
  // @@protoc_insertion_point(field_set:network.GuestOrderInfo.idroom)
}

// optional string guest_firstname = 4;
inline bool GuestOrderInfo::has_guest_firstname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GuestOrderInfo::set_has_guest_firstname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GuestOrderInfo::clear_has_guest_firstname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GuestOrderInfo::clear_guest_firstname() {
  if (guest_firstname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    guest_firstname_->clear();
  }
  clear_has_guest_firstname();
}
inline const ::std::string& GuestOrderInfo::guest_firstname() const {
  // @@protoc_insertion_point(field_get:network.GuestOrderInfo.guest_firstname)
  return *guest_firstname_;
}
inline void GuestOrderInfo::set_guest_firstname(const ::std::string& value) {
  set_has_guest_firstname();
  if (guest_firstname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    guest_firstname_ = new ::std::string;
  }
  guest_firstname_->assign(value);
  // @@protoc_insertion_point(field_set:network.GuestOrderInfo.guest_firstname)
}
inline void GuestOrderInfo::set_guest_firstname(const char* value) {
  set_has_guest_firstname();
  if (guest_firstname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    guest_firstname_ = new ::std::string;
  }
  guest_firstname_->assign(value);
  // @@protoc_insertion_point(field_set_char:network.GuestOrderInfo.guest_firstname)
}
inline void GuestOrderInfo::set_guest_firstname(const char* value, size_t size) {
  set_has_guest_firstname();
  if (guest_firstname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    guest_firstname_ = new ::std::string;
  }
  guest_firstname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:network.GuestOrderInfo.guest_firstname)
}
inline ::std::string* GuestOrderInfo::mutable_guest_firstname() {
  set_has_guest_firstname();
  if (guest_firstname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    guest_firstname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:network.GuestOrderInfo.guest_firstname)
  return guest_firstname_;
}
inline ::std::string* GuestOrderInfo::release_guest_firstname() {
  clear_has_guest_firstname();
  if (guest_firstname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = guest_firstname_;
    guest_firstname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GuestOrderInfo::set_allocated_guest_firstname(::std::string* guest_firstname) {
  if (guest_firstname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete guest_firstname_;
  }
  if (guest_firstname) {
    set_has_guest_firstname();
    guest_firstname_ = guest_firstname;
  } else {
    clear_has_guest_firstname();
    guest_firstname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:network.GuestOrderInfo.guest_firstname)
}

// optional string guest_secondname = 5;
inline bool GuestOrderInfo::has_guest_secondname() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GuestOrderInfo::set_has_guest_secondname() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GuestOrderInfo::clear_has_guest_secondname() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GuestOrderInfo::clear_guest_secondname() {
  if (guest_secondname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    guest_secondname_->clear();
  }
  clear_has_guest_secondname();
}
inline const ::std::string& GuestOrderInfo::guest_secondname() const {
  // @@protoc_insertion_point(field_get:network.GuestOrderInfo.guest_secondname)
  return *guest_secondname_;
}
inline void GuestOrderInfo::set_guest_secondname(const ::std::string& value) {
  set_has_guest_secondname();
  if (guest_secondname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    guest_secondname_ = new ::std::string;
  }
  guest_secondname_->assign(value);
  // @@protoc_insertion_point(field_set:network.GuestOrderInfo.guest_secondname)
}
inline void GuestOrderInfo::set_guest_secondname(const char* value) {
  set_has_guest_secondname();
  if (guest_secondname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    guest_secondname_ = new ::std::string;
  }
  guest_secondname_->assign(value);
  // @@protoc_insertion_point(field_set_char:network.GuestOrderInfo.guest_secondname)
}
inline void GuestOrderInfo::set_guest_secondname(const char* value, size_t size) {
  set_has_guest_secondname();
  if (guest_secondname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    guest_secondname_ = new ::std::string;
  }
  guest_secondname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:network.GuestOrderInfo.guest_secondname)
}
inline ::std::string* GuestOrderInfo::mutable_guest_secondname() {
  set_has_guest_secondname();
  if (guest_secondname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    guest_secondname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:network.GuestOrderInfo.guest_secondname)
  return guest_secondname_;
}
inline ::std::string* GuestOrderInfo::release_guest_secondname() {
  clear_has_guest_secondname();
  if (guest_secondname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = guest_secondname_;
    guest_secondname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GuestOrderInfo::set_allocated_guest_secondname(::std::string* guest_secondname) {
  if (guest_secondname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete guest_secondname_;
  }
  if (guest_secondname) {
    set_has_guest_secondname();
    guest_secondname_ = guest_secondname;
  } else {
    clear_has_guest_secondname();
    guest_secondname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:network.GuestOrderInfo.guest_secondname)
}

// optional string guest_lastname = 6;
inline bool GuestOrderInfo::has_guest_lastname() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GuestOrderInfo::set_has_guest_lastname() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GuestOrderInfo::clear_has_guest_lastname() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GuestOrderInfo::clear_guest_lastname() {
  if (guest_lastname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    guest_lastname_->clear();
  }
  clear_has_guest_lastname();
}
inline const ::std::string& GuestOrderInfo::guest_lastname() const {
  // @@protoc_insertion_point(field_get:network.GuestOrderInfo.guest_lastname)
  return *guest_lastname_;
}
inline void GuestOrderInfo::set_guest_lastname(const ::std::string& value) {
  set_has_guest_lastname();
  if (guest_lastname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    guest_lastname_ = new ::std::string;
  }
  guest_lastname_->assign(value);
  // @@protoc_insertion_point(field_set:network.GuestOrderInfo.guest_lastname)
}
inline void GuestOrderInfo::set_guest_lastname(const char* value) {
  set_has_guest_lastname();
  if (guest_lastname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    guest_lastname_ = new ::std::string;
  }
  guest_lastname_->assign(value);
  // @@protoc_insertion_point(field_set_char:network.GuestOrderInfo.guest_lastname)
}
inline void GuestOrderInfo::set_guest_lastname(const char* value, size_t size) {
  set_has_guest_lastname();
  if (guest_lastname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    guest_lastname_ = new ::std::string;
  }
  guest_lastname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:network.GuestOrderInfo.guest_lastname)
}
inline ::std::string* GuestOrderInfo::mutable_guest_lastname() {
  set_has_guest_lastname();
  if (guest_lastname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    guest_lastname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:network.GuestOrderInfo.guest_lastname)
  return guest_lastname_;
}
inline ::std::string* GuestOrderInfo::release_guest_lastname() {
  clear_has_guest_lastname();
  if (guest_lastname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = guest_lastname_;
    guest_lastname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GuestOrderInfo::set_allocated_guest_lastname(::std::string* guest_lastname) {
  if (guest_lastname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete guest_lastname_;
  }
  if (guest_lastname) {
    set_has_guest_lastname();
    guest_lastname_ = guest_lastname;
  } else {
    clear_has_guest_lastname();
    guest_lastname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:network.GuestOrderInfo.guest_lastname)
}

// -------------------------------------------------------------------

// GuestOrdersMessageResponse

// repeated .network.GuestOrderInfo orders = 1;
inline int GuestOrdersMessageResponse::orders_size() const {
  return orders_.size();
}
inline void GuestOrdersMessageResponse::clear_orders() {
  orders_.Clear();
}
inline const ::network::GuestOrderInfo& GuestOrdersMessageResponse::orders(int index) const {
  // @@protoc_insertion_point(field_get:network.GuestOrdersMessageResponse.orders)
  return orders_.Get(index);
}
inline ::network::GuestOrderInfo* GuestOrdersMessageResponse::mutable_orders(int index) {
  // @@protoc_insertion_point(field_mutable:network.GuestOrdersMessageResponse.orders)
  return orders_.Mutable(index);
}
inline ::network::GuestOrderInfo* GuestOrdersMessageResponse::add_orders() {
  // @@protoc_insertion_point(field_add:network.GuestOrdersMessageResponse.orders)
  return orders_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::network::GuestOrderInfo >&
GuestOrdersMessageResponse::orders() const {
  // @@protoc_insertion_point(field_list:network.GuestOrdersMessageResponse.orders)
  return orders_;
}
inline ::google::protobuf::RepeatedPtrField< ::network::GuestOrderInfo >*
GuestOrdersMessageResponse::mutable_orders() {
  // @@protoc_insertion_point(field_mutable_list:network.GuestOrdersMessageResponse.orders)
  return &orders_;
}

// -------------------------------------------------------------------

// MakeOrderInfo

// optional string startdate = 1;
inline bool MakeOrderInfo::has_startdate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MakeOrderInfo::set_has_startdate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MakeOrderInfo::clear_has_startdate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MakeOrderInfo::clear_startdate() {
  if (startdate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    startdate_->clear();
  }
  clear_has_startdate();
}
inline const ::std::string& MakeOrderInfo::startdate() const {
  // @@protoc_insertion_point(field_get:network.MakeOrderInfo.startdate)
  return *startdate_;
}
inline void MakeOrderInfo::set_startdate(const ::std::string& value) {
  set_has_startdate();
  if (startdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    startdate_ = new ::std::string;
  }
  startdate_->assign(value);
  // @@protoc_insertion_point(field_set:network.MakeOrderInfo.startdate)
}
inline void MakeOrderInfo::set_startdate(const char* value) {
  set_has_startdate();
  if (startdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    startdate_ = new ::std::string;
  }
  startdate_->assign(value);
  // @@protoc_insertion_point(field_set_char:network.MakeOrderInfo.startdate)
}
inline void MakeOrderInfo::set_startdate(const char* value, size_t size) {
  set_has_startdate();
  if (startdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    startdate_ = new ::std::string;
  }
  startdate_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:network.MakeOrderInfo.startdate)
}
inline ::std::string* MakeOrderInfo::mutable_startdate() {
  set_has_startdate();
  if (startdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    startdate_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:network.MakeOrderInfo.startdate)
  return startdate_;
}
inline ::std::string* MakeOrderInfo::release_startdate() {
  clear_has_startdate();
  if (startdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = startdate_;
    startdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MakeOrderInfo::set_allocated_startdate(::std::string* startdate) {
  if (startdate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete startdate_;
  }
  if (startdate) {
    set_has_startdate();
    startdate_ = startdate;
  } else {
    clear_has_startdate();
    startdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:network.MakeOrderInfo.startdate)
}

// optional string enddate = 2;
inline bool MakeOrderInfo::has_enddate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MakeOrderInfo::set_has_enddate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MakeOrderInfo::clear_has_enddate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MakeOrderInfo::clear_enddate() {
  if (enddate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    enddate_->clear();
  }
  clear_has_enddate();
}
inline const ::std::string& MakeOrderInfo::enddate() const {
  // @@protoc_insertion_point(field_get:network.MakeOrderInfo.enddate)
  return *enddate_;
}
inline void MakeOrderInfo::set_enddate(const ::std::string& value) {
  set_has_enddate();
  if (enddate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    enddate_ = new ::std::string;
  }
  enddate_->assign(value);
  // @@protoc_insertion_point(field_set:network.MakeOrderInfo.enddate)
}
inline void MakeOrderInfo::set_enddate(const char* value) {
  set_has_enddate();
  if (enddate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    enddate_ = new ::std::string;
  }
  enddate_->assign(value);
  // @@protoc_insertion_point(field_set_char:network.MakeOrderInfo.enddate)
}
inline void MakeOrderInfo::set_enddate(const char* value, size_t size) {
  set_has_enddate();
  if (enddate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    enddate_ = new ::std::string;
  }
  enddate_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:network.MakeOrderInfo.enddate)
}
inline ::std::string* MakeOrderInfo::mutable_enddate() {
  set_has_enddate();
  if (enddate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    enddate_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:network.MakeOrderInfo.enddate)
  return enddate_;
}
inline ::std::string* MakeOrderInfo::release_enddate() {
  clear_has_enddate();
  if (enddate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = enddate_;
    enddate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MakeOrderInfo::set_allocated_enddate(::std::string* enddate) {
  if (enddate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete enddate_;
  }
  if (enddate) {
    set_has_enddate();
    enddate_ = enddate;
  } else {
    clear_has_enddate();
    enddate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:network.MakeOrderInfo.enddate)
}

// optional int32 idroom = 3;
inline bool MakeOrderInfo::has_idroom() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MakeOrderInfo::set_has_idroom() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MakeOrderInfo::clear_has_idroom() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MakeOrderInfo::clear_idroom() {
  idroom_ = 0;
  clear_has_idroom();
}
inline ::google::protobuf::int32 MakeOrderInfo::idroom() const {
  // @@protoc_insertion_point(field_get:network.MakeOrderInfo.idroom)
  return idroom_;
}
inline void MakeOrderInfo::set_idroom(::google::protobuf::int32 value) {
  set_has_idroom();
  idroom_ = value;
  // @@protoc_insertion_point(field_set:network.MakeOrderInfo.idroom)
}

// optional int32 idemployee = 4;
inline bool MakeOrderInfo::has_idemployee() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MakeOrderInfo::set_has_idemployee() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MakeOrderInfo::clear_has_idemployee() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MakeOrderInfo::clear_idemployee() {
  idemployee_ = 0;
  clear_has_idemployee();
}
inline ::google::protobuf::int32 MakeOrderInfo::idemployee() const {
  // @@protoc_insertion_point(field_get:network.MakeOrderInfo.idemployee)
  return idemployee_;
}
inline void MakeOrderInfo::set_idemployee(::google::protobuf::int32 value) {
  set_has_idemployee();
  idemployee_ = value;
  // @@protoc_insertion_point(field_set:network.MakeOrderInfo.idemployee)
}

// optional int32 idguest = 5;
inline bool MakeOrderInfo::has_idguest() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MakeOrderInfo::set_has_idguest() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MakeOrderInfo::clear_has_idguest() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MakeOrderInfo::clear_idguest() {
  idguest_ = 0;
  clear_has_idguest();
}
inline ::google::protobuf::int32 MakeOrderInfo::idguest() const {
  // @@protoc_insertion_point(field_get:network.MakeOrderInfo.idguest)
  return idguest_;
}
inline void MakeOrderInfo::set_idguest(::google::protobuf::int32 value) {
  set_has_idguest();
  idguest_ = value;
  // @@protoc_insertion_point(field_set:network.MakeOrderInfo.idguest)
}

// -------------------------------------------------------------------

// RequestContext

// optional .network.message_type message_type_ = 1;
inline bool RequestContext::has_message_type_() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestContext::set_has_message_type_() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestContext::clear_has_message_type_() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestContext::clear_message_type_() {
  message_type__ = 0;
  clear_has_message_type_();
}
inline ::network::message_type RequestContext::message_type_() const {
  // @@protoc_insertion_point(field_get:network.RequestContext.message_type_)
  return static_cast< ::network::message_type >(message_type__);
}
inline void RequestContext::set_message_type_(::network::message_type value) {
  assert(::network::message_type_IsValid(value));
  set_has_message_type_();
  message_type__ = value;
  // @@protoc_insertion_point(field_set:network.RequestContext.message_type_)
}

// optional .network.AuthMessage auth_message_ = 2;
inline bool RequestContext::has_auth_message_() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestContext::set_has_auth_message_() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestContext::clear_has_auth_message_() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestContext::clear_auth_message_() {
  if (auth_message__ != NULL) auth_message__->::network::AuthMessage::Clear();
  clear_has_auth_message_();
}
inline const ::network::AuthMessage& RequestContext::auth_message_() const {
  // @@protoc_insertion_point(field_get:network.RequestContext.auth_message_)
  return auth_message__ != NULL ? *auth_message__ : *default_instance_->auth_message__;
}
inline ::network::AuthMessage* RequestContext::mutable_auth_message_() {
  set_has_auth_message_();
  if (auth_message__ == NULL) auth_message__ = new ::network::AuthMessage;
  // @@protoc_insertion_point(field_mutable:network.RequestContext.auth_message_)
  return auth_message__;
}
inline ::network::AuthMessage* RequestContext::release_auth_message_() {
  clear_has_auth_message_();
  ::network::AuthMessage* temp = auth_message__;
  auth_message__ = NULL;
  return temp;
}
inline void RequestContext::set_allocated_auth_message_(::network::AuthMessage* auth_message_) {
  delete auth_message__;
  auth_message__ = auth_message_;
  if (auth_message_) {
    set_has_auth_message_();
  } else {
    clear_has_auth_message_();
  }
  // @@protoc_insertion_point(field_set_allocated:network.RequestContext.auth_message_)
}

// optional .network.RegisterMessage register_message_ = 3;
inline bool RequestContext::has_register_message_() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestContext::set_has_register_message_() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestContext::clear_has_register_message_() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestContext::clear_register_message_() {
  if (register_message__ != NULL) register_message__->::network::RegisterMessage::Clear();
  clear_has_register_message_();
}
inline const ::network::RegisterMessage& RequestContext::register_message_() const {
  // @@protoc_insertion_point(field_get:network.RequestContext.register_message_)
  return register_message__ != NULL ? *register_message__ : *default_instance_->register_message__;
}
inline ::network::RegisterMessage* RequestContext::mutable_register_message_() {
  set_has_register_message_();
  if (register_message__ == NULL) register_message__ = new ::network::RegisterMessage;
  // @@protoc_insertion_point(field_mutable:network.RequestContext.register_message_)
  return register_message__;
}
inline ::network::RegisterMessage* RequestContext::release_register_message_() {
  clear_has_register_message_();
  ::network::RegisterMessage* temp = register_message__;
  register_message__ = NULL;
  return temp;
}
inline void RequestContext::set_allocated_register_message_(::network::RegisterMessage* register_message_) {
  delete register_message__;
  register_message__ = register_message_;
  if (register_message_) {
    set_has_register_message_();
  } else {
    clear_has_register_message_();
  }
  // @@protoc_insertion_point(field_set_allocated:network.RequestContext.register_message_)
}

// optional .network.RegisterEmployeeMessage register_employee_message_ = 4;
inline bool RequestContext::has_register_employee_message_() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestContext::set_has_register_employee_message_() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestContext::clear_has_register_employee_message_() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestContext::clear_register_employee_message_() {
  if (register_employee_message__ != NULL) register_employee_message__->::network::RegisterEmployeeMessage::Clear();
  clear_has_register_employee_message_();
}
inline const ::network::RegisterEmployeeMessage& RequestContext::register_employee_message_() const {
  // @@protoc_insertion_point(field_get:network.RequestContext.register_employee_message_)
  return register_employee_message__ != NULL ? *register_employee_message__ : *default_instance_->register_employee_message__;
}
inline ::network::RegisterEmployeeMessage* RequestContext::mutable_register_employee_message_() {
  set_has_register_employee_message_();
  if (register_employee_message__ == NULL) register_employee_message__ = new ::network::RegisterEmployeeMessage;
  // @@protoc_insertion_point(field_mutable:network.RequestContext.register_employee_message_)
  return register_employee_message__;
}
inline ::network::RegisterEmployeeMessage* RequestContext::release_register_employee_message_() {
  clear_has_register_employee_message_();
  ::network::RegisterEmployeeMessage* temp = register_employee_message__;
  register_employee_message__ = NULL;
  return temp;
}
inline void RequestContext::set_allocated_register_employee_message_(::network::RegisterEmployeeMessage* register_employee_message_) {
  delete register_employee_message__;
  register_employee_message__ = register_employee_message_;
  if (register_employee_message_) {
    set_has_register_employee_message_();
  } else {
    clear_has_register_employee_message_();
  }
  // @@protoc_insertion_point(field_set_allocated:network.RequestContext.register_employee_message_)
}

// optional .network.SessionInfo session_info = 5;
inline bool RequestContext::has_session_info() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RequestContext::set_has_session_info() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RequestContext::clear_has_session_info() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RequestContext::clear_session_info() {
  if (session_info_ != NULL) session_info_->::network::SessionInfo::Clear();
  clear_has_session_info();
}
inline const ::network::SessionInfo& RequestContext::session_info() const {
  // @@protoc_insertion_point(field_get:network.RequestContext.session_info)
  return session_info_ != NULL ? *session_info_ : *default_instance_->session_info_;
}
inline ::network::SessionInfo* RequestContext::mutable_session_info() {
  set_has_session_info();
  if (session_info_ == NULL) session_info_ = new ::network::SessionInfo;
  // @@protoc_insertion_point(field_mutable:network.RequestContext.session_info)
  return session_info_;
}
inline ::network::SessionInfo* RequestContext::release_session_info() {
  clear_has_session_info();
  ::network::SessionInfo* temp = session_info_;
  session_info_ = NULL;
  return temp;
}
inline void RequestContext::set_allocated_session_info(::network::SessionInfo* session_info) {
  delete session_info_;
  session_info_ = session_info;
  if (session_info) {
    set_has_session_info();
  } else {
    clear_has_session_info();
  }
  // @@protoc_insertion_point(field_set_allocated:network.RequestContext.session_info)
}

// optional .network.HotelId hotel_id = 6;
inline bool RequestContext::has_hotel_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RequestContext::set_has_hotel_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RequestContext::clear_has_hotel_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RequestContext::clear_hotel_id() {
  if (hotel_id_ != NULL) hotel_id_->::network::HotelId::Clear();
  clear_has_hotel_id();
}
inline const ::network::HotelId& RequestContext::hotel_id() const {
  // @@protoc_insertion_point(field_get:network.RequestContext.hotel_id)
  return hotel_id_ != NULL ? *hotel_id_ : *default_instance_->hotel_id_;
}
inline ::network::HotelId* RequestContext::mutable_hotel_id() {
  set_has_hotel_id();
  if (hotel_id_ == NULL) hotel_id_ = new ::network::HotelId;
  // @@protoc_insertion_point(field_mutable:network.RequestContext.hotel_id)
  return hotel_id_;
}
inline ::network::HotelId* RequestContext::release_hotel_id() {
  clear_has_hotel_id();
  ::network::HotelId* temp = hotel_id_;
  hotel_id_ = NULL;
  return temp;
}
inline void RequestContext::set_allocated_hotel_id(::network::HotelId* hotel_id) {
  delete hotel_id_;
  hotel_id_ = hotel_id;
  if (hotel_id) {
    set_has_hotel_id();
  } else {
    clear_has_hotel_id();
  }
  // @@protoc_insertion_point(field_set_allocated:network.RequestContext.hotel_id)
}

// optional .network.EmployeeInfo employee_info = 7;
inline bool RequestContext::has_employee_info() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RequestContext::set_has_employee_info() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RequestContext::clear_has_employee_info() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RequestContext::clear_employee_info() {
  if (employee_info_ != NULL) employee_info_->::network::EmployeeInfo::Clear();
  clear_has_employee_info();
}
inline const ::network::EmployeeInfo& RequestContext::employee_info() const {
  // @@protoc_insertion_point(field_get:network.RequestContext.employee_info)
  return employee_info_ != NULL ? *employee_info_ : *default_instance_->employee_info_;
}
inline ::network::EmployeeInfo* RequestContext::mutable_employee_info() {
  set_has_employee_info();
  if (employee_info_ == NULL) employee_info_ = new ::network::EmployeeInfo;
  // @@protoc_insertion_point(field_mutable:network.RequestContext.employee_info)
  return employee_info_;
}
inline ::network::EmployeeInfo* RequestContext::release_employee_info() {
  clear_has_employee_info();
  ::network::EmployeeInfo* temp = employee_info_;
  employee_info_ = NULL;
  return temp;
}
inline void RequestContext::set_allocated_employee_info(::network::EmployeeInfo* employee_info) {
  delete employee_info_;
  employee_info_ = employee_info;
  if (employee_info) {
    set_has_employee_info();
  } else {
    clear_has_employee_info();
  }
  // @@protoc_insertion_point(field_set_allocated:network.RequestContext.employee_info)
}

// optional .network.RoomInfo room_info = 8;
inline bool RequestContext::has_room_info() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RequestContext::set_has_room_info() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RequestContext::clear_has_room_info() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RequestContext::clear_room_info() {
  if (room_info_ != NULL) room_info_->::network::RoomInfo::Clear();
  clear_has_room_info();
}
inline const ::network::RoomInfo& RequestContext::room_info() const {
  // @@protoc_insertion_point(field_get:network.RequestContext.room_info)
  return room_info_ != NULL ? *room_info_ : *default_instance_->room_info_;
}
inline ::network::RoomInfo* RequestContext::mutable_room_info() {
  set_has_room_info();
  if (room_info_ == NULL) room_info_ = new ::network::RoomInfo;
  // @@protoc_insertion_point(field_mutable:network.RequestContext.room_info)
  return room_info_;
}
inline ::network::RoomInfo* RequestContext::release_room_info() {
  clear_has_room_info();
  ::network::RoomInfo* temp = room_info_;
  room_info_ = NULL;
  return temp;
}
inline void RequestContext::set_allocated_room_info(::network::RoomInfo* room_info) {
  delete room_info_;
  room_info_ = room_info;
  if (room_info) {
    set_has_room_info();
  } else {
    clear_has_room_info();
  }
  // @@protoc_insertion_point(field_set_allocated:network.RequestContext.room_info)
}

// optional .network.VacantRooms data = 9;
inline bool RequestContext::has_data() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RequestContext::set_has_data() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RequestContext::clear_has_data() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RequestContext::clear_data() {
  if (data_ != NULL) data_->::network::VacantRooms::Clear();
  clear_has_data();
}
inline const ::network::VacantRooms& RequestContext::data() const {
  // @@protoc_insertion_point(field_get:network.RequestContext.data)
  return data_ != NULL ? *data_ : *default_instance_->data_;
}
inline ::network::VacantRooms* RequestContext::mutable_data() {
  set_has_data();
  if (data_ == NULL) data_ = new ::network::VacantRooms;
  // @@protoc_insertion_point(field_mutable:network.RequestContext.data)
  return data_;
}
inline ::network::VacantRooms* RequestContext::release_data() {
  clear_has_data();
  ::network::VacantRooms* temp = data_;
  data_ = NULL;
  return temp;
}
inline void RequestContext::set_allocated_data(::network::VacantRooms* data) {
  delete data_;
  data_ = data;
  if (data) {
    set_has_data();
  } else {
    clear_has_data();
  }
  // @@protoc_insertion_point(field_set_allocated:network.RequestContext.data)
}

// optional .network.MakeOrderInfo make_order_info = 10;
inline bool RequestContext::has_make_order_info() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RequestContext::set_has_make_order_info() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RequestContext::clear_has_make_order_info() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RequestContext::clear_make_order_info() {
  if (make_order_info_ != NULL) make_order_info_->::network::MakeOrderInfo::Clear();
  clear_has_make_order_info();
}
inline const ::network::MakeOrderInfo& RequestContext::make_order_info() const {
  // @@protoc_insertion_point(field_get:network.RequestContext.make_order_info)
  return make_order_info_ != NULL ? *make_order_info_ : *default_instance_->make_order_info_;
}
inline ::network::MakeOrderInfo* RequestContext::mutable_make_order_info() {
  set_has_make_order_info();
  if (make_order_info_ == NULL) make_order_info_ = new ::network::MakeOrderInfo;
  // @@protoc_insertion_point(field_mutable:network.RequestContext.make_order_info)
  return make_order_info_;
}
inline ::network::MakeOrderInfo* RequestContext::release_make_order_info() {
  clear_has_make_order_info();
  ::network::MakeOrderInfo* temp = make_order_info_;
  make_order_info_ = NULL;
  return temp;
}
inline void RequestContext::set_allocated_make_order_info(::network::MakeOrderInfo* make_order_info) {
  delete make_order_info_;
  make_order_info_ = make_order_info;
  if (make_order_info) {
    set_has_make_order_info();
  } else {
    clear_has_make_order_info();
  }
  // @@protoc_insertion_point(field_set_allocated:network.RequestContext.make_order_info)
}

// -------------------------------------------------------------------

// RegisterMessageResponse

// optional string messageText = 1;
inline bool RegisterMessageResponse::has_messagetext() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegisterMessageResponse::set_has_messagetext() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegisterMessageResponse::clear_has_messagetext() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegisterMessageResponse::clear_messagetext() {
  if (messagetext_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    messagetext_->clear();
  }
  clear_has_messagetext();
}
inline const ::std::string& RegisterMessageResponse::messagetext() const {
  // @@protoc_insertion_point(field_get:network.RegisterMessageResponse.messageText)
  return *messagetext_;
}
inline void RegisterMessageResponse::set_messagetext(const ::std::string& value) {
  set_has_messagetext();
  if (messagetext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    messagetext_ = new ::std::string;
  }
  messagetext_->assign(value);
  // @@protoc_insertion_point(field_set:network.RegisterMessageResponse.messageText)
}
inline void RegisterMessageResponse::set_messagetext(const char* value) {
  set_has_messagetext();
  if (messagetext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    messagetext_ = new ::std::string;
  }
  messagetext_->assign(value);
  // @@protoc_insertion_point(field_set_char:network.RegisterMessageResponse.messageText)
}
inline void RegisterMessageResponse::set_messagetext(const char* value, size_t size) {
  set_has_messagetext();
  if (messagetext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    messagetext_ = new ::std::string;
  }
  messagetext_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:network.RegisterMessageResponse.messageText)
}
inline ::std::string* RegisterMessageResponse::mutable_messagetext() {
  set_has_messagetext();
  if (messagetext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    messagetext_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:network.RegisterMessageResponse.messageText)
  return messagetext_;
}
inline ::std::string* RegisterMessageResponse::release_messagetext() {
  clear_has_messagetext();
  if (messagetext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = messagetext_;
    messagetext_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RegisterMessageResponse::set_allocated_messagetext(::std::string* messagetext) {
  if (messagetext_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete messagetext_;
  }
  if (messagetext) {
    set_has_messagetext();
    messagetext_ = messagetext;
  } else {
    clear_has_messagetext();
    messagetext_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:network.RegisterMessageResponse.messageText)
}

// optional bool status = 2;
inline bool RegisterMessageResponse::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegisterMessageResponse::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegisterMessageResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegisterMessageResponse::clear_status() {
  status_ = false;
  clear_has_status();
}
inline bool RegisterMessageResponse::status() const {
  // @@protoc_insertion_point(field_get:network.RegisterMessageResponse.status)
  return status_;
}
inline void RegisterMessageResponse::set_status(bool value) {
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:network.RegisterMessageResponse.status)
}

// -------------------------------------------------------------------

// AuthMessageResponse

// optional int32 role = 1;
inline bool AuthMessageResponse::has_role() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AuthMessageResponse::set_has_role() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AuthMessageResponse::clear_has_role() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AuthMessageResponse::clear_role() {
  role_ = 0;
  clear_has_role();
}
inline ::google::protobuf::int32 AuthMessageResponse::role() const {
  // @@protoc_insertion_point(field_get:network.AuthMessageResponse.role)
  return role_;
}
inline void AuthMessageResponse::set_role(::google::protobuf::int32 value) {
  set_has_role();
  role_ = value;
  // @@protoc_insertion_point(field_set:network.AuthMessageResponse.role)
}

// optional int32 id_hotel = 2;
inline bool AuthMessageResponse::has_id_hotel() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AuthMessageResponse::set_has_id_hotel() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AuthMessageResponse::clear_has_id_hotel() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AuthMessageResponse::clear_id_hotel() {
  id_hotel_ = 0;
  clear_has_id_hotel();
}
inline ::google::protobuf::int32 AuthMessageResponse::id_hotel() const {
  // @@protoc_insertion_point(field_get:network.AuthMessageResponse.id_hotel)
  return id_hotel_;
}
inline void AuthMessageResponse::set_id_hotel(::google::protobuf::int32 value) {
  set_has_id_hotel();
  id_hotel_ = value;
  // @@protoc_insertion_point(field_set:network.AuthMessageResponse.id_hotel)
}

// optional bool status = 3;
inline bool AuthMessageResponse::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AuthMessageResponse::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AuthMessageResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AuthMessageResponse::clear_status() {
  status_ = false;
  clear_has_status();
}
inline bool AuthMessageResponse::status() const {
  // @@protoc_insertion_point(field_get:network.AuthMessageResponse.status)
  return status_;
}
inline void AuthMessageResponse::set_status(bool value) {
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:network.AuthMessageResponse.status)
}

// optional string messageText = 4;
inline bool AuthMessageResponse::has_messagetext() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AuthMessageResponse::set_has_messagetext() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AuthMessageResponse::clear_has_messagetext() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AuthMessageResponse::clear_messagetext() {
  if (messagetext_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    messagetext_->clear();
  }
  clear_has_messagetext();
}
inline const ::std::string& AuthMessageResponse::messagetext() const {
  // @@protoc_insertion_point(field_get:network.AuthMessageResponse.messageText)
  return *messagetext_;
}
inline void AuthMessageResponse::set_messagetext(const ::std::string& value) {
  set_has_messagetext();
  if (messagetext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    messagetext_ = new ::std::string;
  }
  messagetext_->assign(value);
  // @@protoc_insertion_point(field_set:network.AuthMessageResponse.messageText)
}
inline void AuthMessageResponse::set_messagetext(const char* value) {
  set_has_messagetext();
  if (messagetext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    messagetext_ = new ::std::string;
  }
  messagetext_->assign(value);
  // @@protoc_insertion_point(field_set_char:network.AuthMessageResponse.messageText)
}
inline void AuthMessageResponse::set_messagetext(const char* value, size_t size) {
  set_has_messagetext();
  if (messagetext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    messagetext_ = new ::std::string;
  }
  messagetext_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:network.AuthMessageResponse.messageText)
}
inline ::std::string* AuthMessageResponse::mutable_messagetext() {
  set_has_messagetext();
  if (messagetext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    messagetext_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:network.AuthMessageResponse.messageText)
  return messagetext_;
}
inline ::std::string* AuthMessageResponse::release_messagetext() {
  clear_has_messagetext();
  if (messagetext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = messagetext_;
    messagetext_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AuthMessageResponse::set_allocated_messagetext(::std::string* messagetext) {
  if (messagetext_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete messagetext_;
  }
  if (messagetext) {
    set_has_messagetext();
    messagetext_ = messagetext;
  } else {
    clear_has_messagetext();
    messagetext_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:network.AuthMessageResponse.messageText)
}

// optional int32 id_user = 5;
inline bool AuthMessageResponse::has_id_user() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AuthMessageResponse::set_has_id_user() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AuthMessageResponse::clear_has_id_user() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AuthMessageResponse::clear_id_user() {
  id_user_ = 0;
  clear_has_id_user();
}
inline ::google::protobuf::int32 AuthMessageResponse::id_user() const {
  // @@protoc_insertion_point(field_get:network.AuthMessageResponse.id_user)
  return id_user_;
}
inline void AuthMessageResponse::set_id_user(::google::protobuf::int32 value) {
  set_has_id_user();
  id_user_ = value;
  // @@protoc_insertion_point(field_set:network.AuthMessageResponse.id_user)
}

// -------------------------------------------------------------------

// SessionInfo

// optional string login = 1;
inline bool SessionInfo::has_login() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SessionInfo::set_has_login() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SessionInfo::clear_has_login() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SessionInfo::clear_login() {
  if (login_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    login_->clear();
  }
  clear_has_login();
}
inline const ::std::string& SessionInfo::login() const {
  // @@protoc_insertion_point(field_get:network.SessionInfo.login)
  return *login_;
}
inline void SessionInfo::set_login(const ::std::string& value) {
  set_has_login();
  if (login_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    login_ = new ::std::string;
  }
  login_->assign(value);
  // @@protoc_insertion_point(field_set:network.SessionInfo.login)
}
inline void SessionInfo::set_login(const char* value) {
  set_has_login();
  if (login_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    login_ = new ::std::string;
  }
  login_->assign(value);
  // @@protoc_insertion_point(field_set_char:network.SessionInfo.login)
}
inline void SessionInfo::set_login(const char* value, size_t size) {
  set_has_login();
  if (login_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    login_ = new ::std::string;
  }
  login_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:network.SessionInfo.login)
}
inline ::std::string* SessionInfo::mutable_login() {
  set_has_login();
  if (login_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    login_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:network.SessionInfo.login)
  return login_;
}
inline ::std::string* SessionInfo::release_login() {
  clear_has_login();
  if (login_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = login_;
    login_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SessionInfo::set_allocated_login(::std::string* login) {
  if (login_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete login_;
  }
  if (login) {
    set_has_login();
    login_ = login;
  } else {
    clear_has_login();
    login_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:network.SessionInfo.login)
}

// optional int64 userId = 2;
inline bool SessionInfo::has_userid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SessionInfo::set_has_userid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SessionInfo::clear_has_userid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SessionInfo::clear_userid() {
  userid_ = GOOGLE_LONGLONG(0);
  clear_has_userid();
}
inline ::google::protobuf::int64 SessionInfo::userid() const {
  // @@protoc_insertion_point(field_get:network.SessionInfo.userId)
  return userid_;
}
inline void SessionInfo::set_userid(::google::protobuf::int64 value) {
  set_has_userid();
  userid_ = value;
  // @@protoc_insertion_point(field_set:network.SessionInfo.userId)
}

// optional int32 role = 3;
inline bool SessionInfo::has_role() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SessionInfo::set_has_role() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SessionInfo::clear_has_role() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SessionInfo::clear_role() {
  role_ = 0;
  clear_has_role();
}
inline ::google::protobuf::int32 SessionInfo::role() const {
  // @@protoc_insertion_point(field_get:network.SessionInfo.role)
  return role_;
}
inline void SessionInfo::set_role(::google::protobuf::int32 value) {
  set_has_role();
  role_ = value;
  // @@protoc_insertion_point(field_set:network.SessionInfo.role)
}

// optional string session_id = 4;
inline bool SessionInfo::has_session_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SessionInfo::set_has_session_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SessionInfo::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SessionInfo::clear_session_id() {
  if (session_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_id_->clear();
  }
  clear_has_session_id();
}
inline const ::std::string& SessionInfo::session_id() const {
  // @@protoc_insertion_point(field_get:network.SessionInfo.session_id)
  return *session_id_;
}
inline void SessionInfo::set_session_id(const ::std::string& value) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(value);
  // @@protoc_insertion_point(field_set:network.SessionInfo.session_id)
}
inline void SessionInfo::set_session_id(const char* value) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:network.SessionInfo.session_id)
}
inline void SessionInfo::set_session_id(const char* value, size_t size) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:network.SessionInfo.session_id)
}
inline ::std::string* SessionInfo::mutable_session_id() {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:network.SessionInfo.session_id)
  return session_id_;
}
inline ::std::string* SessionInfo::release_session_id() {
  clear_has_session_id();
  if (session_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = session_id_;
    session_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SessionInfo::set_allocated_session_id(::std::string* session_id) {
  if (session_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete session_id_;
  }
  if (session_id) {
    set_has_session_id();
    session_id_ = session_id;
  } else {
    clear_has_session_id();
    session_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:network.SessionInfo.session_id)
}

// -------------------------------------------------------------------

// RoomTypesMessageResponse

// repeated string types = 1;
inline int RoomTypesMessageResponse::types_size() const {
  return types_.size();
}
inline void RoomTypesMessageResponse::clear_types() {
  types_.Clear();
}
inline const ::std::string& RoomTypesMessageResponse::types(int index) const {
  // @@protoc_insertion_point(field_get:network.RoomTypesMessageResponse.types)
  return types_.Get(index);
}
inline ::std::string* RoomTypesMessageResponse::mutable_types(int index) {
  // @@protoc_insertion_point(field_mutable:network.RoomTypesMessageResponse.types)
  return types_.Mutable(index);
}
inline void RoomTypesMessageResponse::set_types(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:network.RoomTypesMessageResponse.types)
  types_.Mutable(index)->assign(value);
}
inline void RoomTypesMessageResponse::set_types(int index, const char* value) {
  types_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:network.RoomTypesMessageResponse.types)
}
inline void RoomTypesMessageResponse::set_types(int index, const char* value, size_t size) {
  types_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:network.RoomTypesMessageResponse.types)
}
inline ::std::string* RoomTypesMessageResponse::add_types() {
  return types_.Add();
}
inline void RoomTypesMessageResponse::add_types(const ::std::string& value) {
  types_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:network.RoomTypesMessageResponse.types)
}
inline void RoomTypesMessageResponse::add_types(const char* value) {
  types_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:network.RoomTypesMessageResponse.types)
}
inline void RoomTypesMessageResponse::add_types(const char* value, size_t size) {
  types_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:network.RoomTypesMessageResponse.types)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RoomTypesMessageResponse::types() const {
  // @@protoc_insertion_point(field_list:network.RoomTypesMessageResponse.types)
  return types_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RoomTypesMessageResponse::mutable_types() {
  // @@protoc_insertion_point(field_mutable_list:network.RoomTypesMessageResponse.types)
  return &types_;
}

// -------------------------------------------------------------------

// HotelType

// optional int32 id = 1;
inline bool HotelType::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HotelType::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HotelType::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HotelType::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 HotelType::id() const {
  // @@protoc_insertion_point(field_get:network.HotelType.id)
  return id_;
}
inline void HotelType::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:network.HotelType.id)
}

// optional string name = 2;
inline bool HotelType::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HotelType::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HotelType::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HotelType::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& HotelType::name() const {
  // @@protoc_insertion_point(field_get:network.HotelType.name)
  return *name_;
}
inline void HotelType::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:network.HotelType.name)
}
inline void HotelType::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:network.HotelType.name)
}
inline void HotelType::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:network.HotelType.name)
}
inline ::std::string* HotelType::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:network.HotelType.name)
  return name_;
}
inline ::std::string* HotelType::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void HotelType::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:network.HotelType.name)
}

// -------------------------------------------------------------------

// HotelTypesMessageResponse

// repeated .network.HotelType types = 1;
inline int HotelTypesMessageResponse::types_size() const {
  return types_.size();
}
inline void HotelTypesMessageResponse::clear_types() {
  types_.Clear();
}
inline const ::network::HotelType& HotelTypesMessageResponse::types(int index) const {
  // @@protoc_insertion_point(field_get:network.HotelTypesMessageResponse.types)
  return types_.Get(index);
}
inline ::network::HotelType* HotelTypesMessageResponse::mutable_types(int index) {
  // @@protoc_insertion_point(field_mutable:network.HotelTypesMessageResponse.types)
  return types_.Mutable(index);
}
inline ::network::HotelType* HotelTypesMessageResponse::add_types() {
  // @@protoc_insertion_point(field_add:network.HotelTypesMessageResponse.types)
  return types_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::network::HotelType >&
HotelTypesMessageResponse::types() const {
  // @@protoc_insertion_point(field_list:network.HotelTypesMessageResponse.types)
  return types_;
}
inline ::google::protobuf::RepeatedPtrField< ::network::HotelType >*
HotelTypesMessageResponse::mutable_types() {
  // @@protoc_insertion_point(field_mutable_list:network.HotelTypesMessageResponse.types)
  return &types_;
}

// -------------------------------------------------------------------

// ResponseContext

// optional int32 error_code = 1;
inline bool ResponseContext::has_error_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseContext::set_has_error_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseContext::clear_has_error_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseContext::clear_error_code() {
  error_code_ = 0;
  clear_has_error_code();
}
inline ::google::protobuf::int32 ResponseContext::error_code() const {
  // @@protoc_insertion_point(field_get:network.ResponseContext.error_code)
  return error_code_;
}
inline void ResponseContext::set_error_code(::google::protobuf::int32 value) {
  set_has_error_code();
  error_code_ = value;
  // @@protoc_insertion_point(field_set:network.ResponseContext.error_code)
}

// optional .network.message_type message_type_ = 2;
inline bool ResponseContext::has_message_type_() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseContext::set_has_message_type_() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseContext::clear_has_message_type_() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseContext::clear_message_type_() {
  message_type__ = 0;
  clear_has_message_type_();
}
inline ::network::message_type ResponseContext::message_type_() const {
  // @@protoc_insertion_point(field_get:network.ResponseContext.message_type_)
  return static_cast< ::network::message_type >(message_type__);
}
inline void ResponseContext::set_message_type_(::network::message_type value) {
  assert(::network::message_type_IsValid(value));
  set_has_message_type_();
  message_type__ = value;
  // @@protoc_insertion_point(field_set:network.ResponseContext.message_type_)
}

// optional .network.RegisterMessageResponse register_response = 3;
inline bool ResponseContext::has_register_response() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResponseContext::set_has_register_response() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResponseContext::clear_has_register_response() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResponseContext::clear_register_response() {
  if (register_response_ != NULL) register_response_->::network::RegisterMessageResponse::Clear();
  clear_has_register_response();
}
inline const ::network::RegisterMessageResponse& ResponseContext::register_response() const {
  // @@protoc_insertion_point(field_get:network.ResponseContext.register_response)
  return register_response_ != NULL ? *register_response_ : *default_instance_->register_response_;
}
inline ::network::RegisterMessageResponse* ResponseContext::mutable_register_response() {
  set_has_register_response();
  if (register_response_ == NULL) register_response_ = new ::network::RegisterMessageResponse;
  // @@protoc_insertion_point(field_mutable:network.ResponseContext.register_response)
  return register_response_;
}
inline ::network::RegisterMessageResponse* ResponseContext::release_register_response() {
  clear_has_register_response();
  ::network::RegisterMessageResponse* temp = register_response_;
  register_response_ = NULL;
  return temp;
}
inline void ResponseContext::set_allocated_register_response(::network::RegisterMessageResponse* register_response) {
  delete register_response_;
  register_response_ = register_response;
  if (register_response) {
    set_has_register_response();
  } else {
    clear_has_register_response();
  }
  // @@protoc_insertion_point(field_set_allocated:network.ResponseContext.register_response)
}

// optional .network.AuthMessageResponse auth_response = 4;
inline bool ResponseContext::has_auth_response() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResponseContext::set_has_auth_response() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ResponseContext::clear_has_auth_response() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ResponseContext::clear_auth_response() {
  if (auth_response_ != NULL) auth_response_->::network::AuthMessageResponse::Clear();
  clear_has_auth_response();
}
inline const ::network::AuthMessageResponse& ResponseContext::auth_response() const {
  // @@protoc_insertion_point(field_get:network.ResponseContext.auth_response)
  return auth_response_ != NULL ? *auth_response_ : *default_instance_->auth_response_;
}
inline ::network::AuthMessageResponse* ResponseContext::mutable_auth_response() {
  set_has_auth_response();
  if (auth_response_ == NULL) auth_response_ = new ::network::AuthMessageResponse;
  // @@protoc_insertion_point(field_mutable:network.ResponseContext.auth_response)
  return auth_response_;
}
inline ::network::AuthMessageResponse* ResponseContext::release_auth_response() {
  clear_has_auth_response();
  ::network::AuthMessageResponse* temp = auth_response_;
  auth_response_ = NULL;
  return temp;
}
inline void ResponseContext::set_allocated_auth_response(::network::AuthMessageResponse* auth_response) {
  delete auth_response_;
  auth_response_ = auth_response;
  if (auth_response) {
    set_has_auth_response();
  } else {
    clear_has_auth_response();
  }
  // @@protoc_insertion_point(field_set_allocated:network.ResponseContext.auth_response)
}

// optional .network.SessionInfo session_info = 5;
inline bool ResponseContext::has_session_info() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ResponseContext::set_has_session_info() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ResponseContext::clear_has_session_info() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ResponseContext::clear_session_info() {
  if (session_info_ != NULL) session_info_->::network::SessionInfo::Clear();
  clear_has_session_info();
}
inline const ::network::SessionInfo& ResponseContext::session_info() const {
  // @@protoc_insertion_point(field_get:network.ResponseContext.session_info)
  return session_info_ != NULL ? *session_info_ : *default_instance_->session_info_;
}
inline ::network::SessionInfo* ResponseContext::mutable_session_info() {
  set_has_session_info();
  if (session_info_ == NULL) session_info_ = new ::network::SessionInfo;
  // @@protoc_insertion_point(field_mutable:network.ResponseContext.session_info)
  return session_info_;
}
inline ::network::SessionInfo* ResponseContext::release_session_info() {
  clear_has_session_info();
  ::network::SessionInfo* temp = session_info_;
  session_info_ = NULL;
  return temp;
}
inline void ResponseContext::set_allocated_session_info(::network::SessionInfo* session_info) {
  delete session_info_;
  session_info_ = session_info;
  if (session_info) {
    set_has_session_info();
  } else {
    clear_has_session_info();
  }
  // @@protoc_insertion_point(field_set_allocated:network.ResponseContext.session_info)
}

// optional .network.GuestsMessageResponse guests = 6;
inline bool ResponseContext::has_guests() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ResponseContext::set_has_guests() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ResponseContext::clear_has_guests() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ResponseContext::clear_guests() {
  if (guests_ != NULL) guests_->::network::GuestsMessageResponse::Clear();
  clear_has_guests();
}
inline const ::network::GuestsMessageResponse& ResponseContext::guests() const {
  // @@protoc_insertion_point(field_get:network.ResponseContext.guests)
  return guests_ != NULL ? *guests_ : *default_instance_->guests_;
}
inline ::network::GuestsMessageResponse* ResponseContext::mutable_guests() {
  set_has_guests();
  if (guests_ == NULL) guests_ = new ::network::GuestsMessageResponse;
  // @@protoc_insertion_point(field_mutable:network.ResponseContext.guests)
  return guests_;
}
inline ::network::GuestsMessageResponse* ResponseContext::release_guests() {
  clear_has_guests();
  ::network::GuestsMessageResponse* temp = guests_;
  guests_ = NULL;
  return temp;
}
inline void ResponseContext::set_allocated_guests(::network::GuestsMessageResponse* guests) {
  delete guests_;
  guests_ = guests;
  if (guests) {
    set_has_guests();
  } else {
    clear_has_guests();
  }
  // @@protoc_insertion_point(field_set_allocated:network.ResponseContext.guests)
}

// optional .network.EmployeesMessageResponse employees = 7;
inline bool ResponseContext::has_employees() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ResponseContext::set_has_employees() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ResponseContext::clear_has_employees() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ResponseContext::clear_employees() {
  if (employees_ != NULL) employees_->::network::EmployeesMessageResponse::Clear();
  clear_has_employees();
}
inline const ::network::EmployeesMessageResponse& ResponseContext::employees() const {
  // @@protoc_insertion_point(field_get:network.ResponseContext.employees)
  return employees_ != NULL ? *employees_ : *default_instance_->employees_;
}
inline ::network::EmployeesMessageResponse* ResponseContext::mutable_employees() {
  set_has_employees();
  if (employees_ == NULL) employees_ = new ::network::EmployeesMessageResponse;
  // @@protoc_insertion_point(field_mutable:network.ResponseContext.employees)
  return employees_;
}
inline ::network::EmployeesMessageResponse* ResponseContext::release_employees() {
  clear_has_employees();
  ::network::EmployeesMessageResponse* temp = employees_;
  employees_ = NULL;
  return temp;
}
inline void ResponseContext::set_allocated_employees(::network::EmployeesMessageResponse* employees) {
  delete employees_;
  employees_ = employees;
  if (employees) {
    set_has_employees();
  } else {
    clear_has_employees();
  }
  // @@protoc_insertion_point(field_set_allocated:network.ResponseContext.employees)
}

// optional .network.HotelsMessageResponse hotels = 8;
inline bool ResponseContext::has_hotels() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ResponseContext::set_has_hotels() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ResponseContext::clear_has_hotels() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ResponseContext::clear_hotels() {
  if (hotels_ != NULL) hotels_->::network::HotelsMessageResponse::Clear();
  clear_has_hotels();
}
inline const ::network::HotelsMessageResponse& ResponseContext::hotels() const {
  // @@protoc_insertion_point(field_get:network.ResponseContext.hotels)
  return hotels_ != NULL ? *hotels_ : *default_instance_->hotels_;
}
inline ::network::HotelsMessageResponse* ResponseContext::mutable_hotels() {
  set_has_hotels();
  if (hotels_ == NULL) hotels_ = new ::network::HotelsMessageResponse;
  // @@protoc_insertion_point(field_mutable:network.ResponseContext.hotels)
  return hotels_;
}
inline ::network::HotelsMessageResponse* ResponseContext::release_hotels() {
  clear_has_hotels();
  ::network::HotelsMessageResponse* temp = hotels_;
  hotels_ = NULL;
  return temp;
}
inline void ResponseContext::set_allocated_hotels(::network::HotelsMessageResponse* hotels) {
  delete hotels_;
  hotels_ = hotels;
  if (hotels) {
    set_has_hotels();
  } else {
    clear_has_hotels();
  }
  // @@protoc_insertion_point(field_set_allocated:network.ResponseContext.hotels)
}

// optional .network.RoomsMessageResponse rooms = 9;
inline bool ResponseContext::has_rooms() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ResponseContext::set_has_rooms() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ResponseContext::clear_has_rooms() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ResponseContext::clear_rooms() {
  if (rooms_ != NULL) rooms_->::network::RoomsMessageResponse::Clear();
  clear_has_rooms();
}
inline const ::network::RoomsMessageResponse& ResponseContext::rooms() const {
  // @@protoc_insertion_point(field_get:network.ResponseContext.rooms)
  return rooms_ != NULL ? *rooms_ : *default_instance_->rooms_;
}
inline ::network::RoomsMessageResponse* ResponseContext::mutable_rooms() {
  set_has_rooms();
  if (rooms_ == NULL) rooms_ = new ::network::RoomsMessageResponse;
  // @@protoc_insertion_point(field_mutable:network.ResponseContext.rooms)
  return rooms_;
}
inline ::network::RoomsMessageResponse* ResponseContext::release_rooms() {
  clear_has_rooms();
  ::network::RoomsMessageResponse* temp = rooms_;
  rooms_ = NULL;
  return temp;
}
inline void ResponseContext::set_allocated_rooms(::network::RoomsMessageResponse* rooms) {
  delete rooms_;
  rooms_ = rooms;
  if (rooms) {
    set_has_rooms();
  } else {
    clear_has_rooms();
  }
  // @@protoc_insertion_point(field_set_allocated:network.ResponseContext.rooms)
}

// optional .network.RoomTypesMessageResponse types = 10;
inline bool ResponseContext::has_types() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ResponseContext::set_has_types() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ResponseContext::clear_has_types() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ResponseContext::clear_types() {
  if (types_ != NULL) types_->::network::RoomTypesMessageResponse::Clear();
  clear_has_types();
}
inline const ::network::RoomTypesMessageResponse& ResponseContext::types() const {
  // @@protoc_insertion_point(field_get:network.ResponseContext.types)
  return types_ != NULL ? *types_ : *default_instance_->types_;
}
inline ::network::RoomTypesMessageResponse* ResponseContext::mutable_types() {
  set_has_types();
  if (types_ == NULL) types_ = new ::network::RoomTypesMessageResponse;
  // @@protoc_insertion_point(field_mutable:network.ResponseContext.types)
  return types_;
}
inline ::network::RoomTypesMessageResponse* ResponseContext::release_types() {
  clear_has_types();
  ::network::RoomTypesMessageResponse* temp = types_;
  types_ = NULL;
  return temp;
}
inline void ResponseContext::set_allocated_types(::network::RoomTypesMessageResponse* types) {
  delete types_;
  types_ = types;
  if (types) {
    set_has_types();
  } else {
    clear_has_types();
  }
  // @@protoc_insertion_point(field_set_allocated:network.ResponseContext.types)
}

// optional .network.OrdersMessageResponse orders = 11;
inline bool ResponseContext::has_orders() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ResponseContext::set_has_orders() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ResponseContext::clear_has_orders() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ResponseContext::clear_orders() {
  if (orders_ != NULL) orders_->::network::OrdersMessageResponse::Clear();
  clear_has_orders();
}
inline const ::network::OrdersMessageResponse& ResponseContext::orders() const {
  // @@protoc_insertion_point(field_get:network.ResponseContext.orders)
  return orders_ != NULL ? *orders_ : *default_instance_->orders_;
}
inline ::network::OrdersMessageResponse* ResponseContext::mutable_orders() {
  set_has_orders();
  if (orders_ == NULL) orders_ = new ::network::OrdersMessageResponse;
  // @@protoc_insertion_point(field_mutable:network.ResponseContext.orders)
  return orders_;
}
inline ::network::OrdersMessageResponse* ResponseContext::release_orders() {
  clear_has_orders();
  ::network::OrdersMessageResponse* temp = orders_;
  orders_ = NULL;
  return temp;
}
inline void ResponseContext::set_allocated_orders(::network::OrdersMessageResponse* orders) {
  delete orders_;
  orders_ = orders;
  if (orders) {
    set_has_orders();
  } else {
    clear_has_orders();
  }
  // @@protoc_insertion_point(field_set_allocated:network.ResponseContext.orders)
}

// optional .network.HotelTypesMessageResponse hotel_types = 12;
inline bool ResponseContext::has_hotel_types() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ResponseContext::set_has_hotel_types() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ResponseContext::clear_has_hotel_types() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ResponseContext::clear_hotel_types() {
  if (hotel_types_ != NULL) hotel_types_->::network::HotelTypesMessageResponse::Clear();
  clear_has_hotel_types();
}
inline const ::network::HotelTypesMessageResponse& ResponseContext::hotel_types() const {
  // @@protoc_insertion_point(field_get:network.ResponseContext.hotel_types)
  return hotel_types_ != NULL ? *hotel_types_ : *default_instance_->hotel_types_;
}
inline ::network::HotelTypesMessageResponse* ResponseContext::mutable_hotel_types() {
  set_has_hotel_types();
  if (hotel_types_ == NULL) hotel_types_ = new ::network::HotelTypesMessageResponse;
  // @@protoc_insertion_point(field_mutable:network.ResponseContext.hotel_types)
  return hotel_types_;
}
inline ::network::HotelTypesMessageResponse* ResponseContext::release_hotel_types() {
  clear_has_hotel_types();
  ::network::HotelTypesMessageResponse* temp = hotel_types_;
  hotel_types_ = NULL;
  return temp;
}
inline void ResponseContext::set_allocated_hotel_types(::network::HotelTypesMessageResponse* hotel_types) {
  delete hotel_types_;
  hotel_types_ = hotel_types;
  if (hotel_types) {
    set_has_hotel_types();
  } else {
    clear_has_hotel_types();
  }
  // @@protoc_insertion_point(field_set_allocated:network.ResponseContext.hotel_types)
}

// optional .network.GuestOrdersMessageResponse guest_orders = 13;
inline bool ResponseContext::has_guest_orders() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ResponseContext::set_has_guest_orders() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ResponseContext::clear_has_guest_orders() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ResponseContext::clear_guest_orders() {
  if (guest_orders_ != NULL) guest_orders_->::network::GuestOrdersMessageResponse::Clear();
  clear_has_guest_orders();
}
inline const ::network::GuestOrdersMessageResponse& ResponseContext::guest_orders() const {
  // @@protoc_insertion_point(field_get:network.ResponseContext.guest_orders)
  return guest_orders_ != NULL ? *guest_orders_ : *default_instance_->guest_orders_;
}
inline ::network::GuestOrdersMessageResponse* ResponseContext::mutable_guest_orders() {
  set_has_guest_orders();
  if (guest_orders_ == NULL) guest_orders_ = new ::network::GuestOrdersMessageResponse;
  // @@protoc_insertion_point(field_mutable:network.ResponseContext.guest_orders)
  return guest_orders_;
}
inline ::network::GuestOrdersMessageResponse* ResponseContext::release_guest_orders() {
  clear_has_guest_orders();
  ::network::GuestOrdersMessageResponse* temp = guest_orders_;
  guest_orders_ = NULL;
  return temp;
}
inline void ResponseContext::set_allocated_guest_orders(::network::GuestOrdersMessageResponse* guest_orders) {
  delete guest_orders_;
  guest_orders_ = guest_orders;
  if (guest_orders) {
    set_has_guest_orders();
  } else {
    clear_has_guest_orders();
  }
  // @@protoc_insertion_point(field_set_allocated:network.ResponseContext.guest_orders)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace network

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Message_2eproto__INCLUDED
